

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/2.jpg">
  <link rel="icon" href="/img/2.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ramoor">
  <meta name="keywords" content="">
  
    <meta name="description" content="在老师的推荐下，我学习了《Introduction To Modern Cryptography》一书的部分内容，本文用来记录阅读过程中的一些随笔，可能会有些潦草，如果往后有了更深的认识，会回来继续完善。 这是我第一次大篇幅阅读英文书籍，刚开始读确实比较难以接受，因为要频繁地搜索一些单词含义，有时候一些地方中文翻译之后与原文含义相差甚远，因此还是硬着头皮大概过了一下原文。读的过程中我发现本书会花费">
<meta property="og:type" content="article">
<meta property="og:title" content="Introduction To Modern Cryptography学习随笔">
<meta property="og:url" content="http://ramoor.github.io/2025/04/28/Introduction%20To%20Modern%20Cryptography%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/index.html">
<meta property="og:site_name" content="Ramoor">
<meta property="og:description" content="在老师的推荐下，我学习了《Introduction To Modern Cryptography》一书的部分内容，本文用来记录阅读过程中的一些随笔，可能会有些潦草，如果往后有了更深的认识，会回来继续完善。 这是我第一次大篇幅阅读英文书籍，刚开始读确实比较难以接受，因为要频繁地搜索一些单词含义，有时候一些地方中文翻译之后与原文含义相差甚远，因此还是硬着头皮大概过了一下原文。读的过程中我发现本书会花费">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ramoor.github.io/2025/04/28/Introduction%20To%20Modern%20Cryptography%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/file-20250422161507480.png">
<meta property="og:image" content="http://ramoor.github.io/2025/04/28/Introduction%20To%20Modern%20Cryptography%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/file-20250425203749171.png">
<meta property="article:published_time" content="2025-04-28T11:55:19.000Z">
<meta property="article:modified_time" content="2025-05-08T04:49:38.267Z">
<meta property="article:author" content="Ramoor">
<meta property="article:tag" content="Crypto">
<meta property="article:tag" content="密码">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://ramoor.github.io/2025/04/28/Introduction%20To%20Modern%20Cryptography%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/file-20250422161507480.png">
  
  
  
  <title>Introduction To Modern Cryptography学习随笔 - Ramoor</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ramoor.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"lPTos9qTFk57xeK53vE7I61e-MdYXbMMI","app_key":"DpXRDnV0ErOnqjSiWrfRvGWm","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ramoor</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/6.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Introduction To Modern Cryptography学习随笔"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-28 19:55" pubdate>
          2025年4月28日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          126 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span>次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Introduction To Modern Cryptography学习随笔</h1>
            
            
              <div class="markdown-body">
                
                <p>在老师的推荐下，我学习了《Introduction To Modern Cryptography》一书的部分内容，本文用来记录阅读过程中的一些随笔，可能会有些潦草，如果往后有了更深的认识，会回来继续完善。</p>
<p>这是我第一次大篇幅阅读英文书籍，刚开始读确实比较难以接受，因为要频繁地搜索一些单词含义，有时候一些地方中文翻译之后与原文含义相差甚远，因此还是硬着头皮大概过了一下原文。<br>读的过程中我发现本书会花费大量的篇幅去论述一个定义，很适合初学者去接触理解每个定义的深层次含义。</p>
<h1 id="3-私钥密码"><a href="#3-私钥密码" class="headerlink" title="3.私钥密码"></a>3.私钥密码</h1><h2 id="3-1-计算安全性"><a href="#3-1-计算安全性" class="headerlink" title="3.1 计算安全性"></a>3.1 计算安全性</h2><p><strong>计算安全相对于信息论安全（完美安全）包含两个放松</strong></p>
<ul>
<li>仅针对有效攻击者（合理时间或有限资源）</li>
<li>允许攻击者有较小概率成功（概率足够小，可忽略不计）</li>
</ul>
<h3 id="3-1-1-具体方法"><a href="#3-1-1-具体方法" class="headerlink" title="3.1.1 具体方法"></a>3.1.1 具体方法</h3><p>计算安全的具体方法通过明确限定<strong>时间</strong>和<strong>计算资源</strong>下，攻击者的最大成功概率，来量化加密方案的安全性。具体的安全性定义形式如下：</p>
<ul>
<li>如果任意一个时间上限为$t$的攻击者都不能以成功概率高于$\epsilon$的概率破解加密方案，这个方案便是$(t,\epsilon)-安全$ 的。</li>
</ul>
<h3 id="3-1-2-渐近方法"><a href="#3-1-2-渐近方法" class="headerlink" title="3.1.2 渐近方法"></a>3.1.2 渐近方法</h3><p>具体安全性方法存在一些技术和理论上的困难。因此在抽象描述方案时使用，使用渐近方法。引入安全性参数$n$，并让其与密钥长度对应，把对手的运行时间和成功概率视为安全参数的函数。</p>
<h4 id="渐近法详细说明"><a href="#渐近法详细说明" class="headerlink" title="渐近法详细说明"></a>渐近法详细说明</h4><ul>
<li><strong>有效算法：</strong> 将“有效对手”等同于运行时间在$n$的多项式内的随机化（即概率性）算法。这意味着存在某个多项式$p$，当安全参数为$n$时，对手的运行时间不超过$p(n)$。</li>
<li><strong>可忽略成功率：</strong> 将“成功概率小”这一概念等同于小于$n$的任何逆多项式的成功概率。即$\epsilon &lt; \frac{1}{p(n)}$</li>
</ul>
<blockquote>
<p><strong>多项式时间：</strong> 时间复杂度为$O(1)、O(nlog_n)、O(n^k)，其中k为某个常数$，等形式所需要的时间的为多项式时间。<br><strong>非（超）多项式时间：</strong> 如时间复杂为$O(n!)、O(a^n)$，等算法所需要的时间为非（超）多项式时间。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>任何安全定义由两部分组成</strong>：</p>
<ul>
<li>对方案的“攻破”（即安全目标）</li>
<li>对对手能力的详细说明（即威胁模型）</li>
</ul>
<p><strong>渐近安全定义：</strong><br>如果每个ppt攻击者A执行某个特定类型的攻击，对于每个多项式$p(·)$，存在一个整数$N$，当安全参数$n$大于$N$时，攻击者成功破解的概率小于$\frac {1}{p(n)}$​，成功概率小于$\frac {1}{p(n)}$，则这个方案是安全的。</p>
<blockquote>
<p><strong>ppt攻击者</strong>：即“概率多项式时间（probabilistic polynomial-time）攻击者”。这意味着攻击者是一个随机化算法，其运行时间是安全参数n的多项式函数。</p>
</blockquote>
<h4 id="论渐近安全的定义选择"><a href="#论渐近安全的定义选择" class="headerlink" title="论渐近安全的定义选择"></a>论渐近安全的定义选择</h4><p><strong>两个选择：</strong></p>
<ul>
<li>将有效的对抗策略与概率多项式时间算法相对应，</li>
<li>将小的成功概率等同于可忽略的概率</li>
</ul>
<h4 id="宽松的必要性"><a href="#宽松的必要性" class="headerlink" title="宽松的必要性"></a>宽松的必要性</h4><p><strong>完美安全的限制：</strong> 密钥空间|K|必须和密文空间|M|一样大，不现实。</p>
<h2 id="3-2-定义计算安全加密"><a href="#3-2-定义计算安全加密" class="headerlink" title="3.2 定义计算安全加密"></a>3.2 定义计算安全加密</h2><p>针对私钥加密的计算安全性定义</p>
<h3 id="3-2-1-基本安全定义（EAV安全）"><a href="#3-2-1-基本安全定义（EAV安全）" class="headerlink" title="3.2.1 基本安全定义（EAV安全）"></a>3.2.1 基本安全定义（EAV安全）</h3><blockquote>
<p>EAV安全：即Eavesdropper Attack Security，攻击者仅观察单个密文，核心在于不可区分性。</p>
</blockquote>
<p>针对仅密文攻击的安全性，即对手只观察到密文，或者给定密钥只能加密单个消息。</p>
<ul>
<li>定义动机<br><strong>威胁模型</strong>：定义攻击者的假设能力，只能观察到单个密文,并在多项式时间内运行。<br><strong>安全目标</strong>：定义什么情况下加密方案被认为是被“破解”的，安全目标是攻击者无法从密文中获取任何关于明文的部分信息</li>
</ul>
<blockquote>
<p>这里的<strong>安全目标</strong>只是一个思想，这个思想概念的明确化在后边的语义安全定义给出，但由于语义安全较为复杂且难以处理，这里介绍一个与语义安全等价的定义——不可区分性。</p>
</blockquote>
<ul>
<li>窃听者存在下的不可区分性<br>定义：一个私钥加密方案$Π$是“在窃听者存在的情况下不可区分的”，如果对于所有概率多项式时间攻击者A，存在一个可忽略函数$negl$，使得对于所有安全参数n：<br>$Pr[PrivKeav_{A,Π}​(n)&#x3D;1]≤\frac 12​+negl(n)$<br>等效表述：<br>$∣Pr[out_A​(PrivKeav_{A,Π}​(n,0))&#x3D;1]−Pr[out_A​(PrivKeav_{A,Π}​(n,1))&#x3D;1]∣≤negl(n)$</li>
</ul>
<h4 id="揭示明文长度"><a href="#揭示明文长度" class="headerlink" title="揭示明文长度"></a>揭示明文长度</h4><p><strong>默认</strong>的安全加密定义中，不要求加密方案隐藏明文长度，但几乎所有常用的加密方案都会泄露明文长度（或其近似值）<br><strong>明文长度泄露可能导致的问题：</strong></p>
<ul>
<li><strong>简单数字&#x2F;文本数据：</strong> 对于敏感信息可能会造成泄露，如个人收入位数不同也就可能暴露收入水平</li>
<li><strong>自动补全功能：</strong> 这个自动补全列表大小可能揭示用户迄今为止输入的字母</li>
<li><strong>数据库搜索：</strong> 返回的记录数量可能会泄露用户搜索的内容</li>
<li><strong>压缩数据：</strong> 较短的压缩明文可能表明原始明文存在大量冗余</li>
</ul>
<h3 id="3-2-2-语义安全"><a href="#3-2-2-语义安全" class="headerlink" title="3.2.2 语义安全"></a>3.2.2 语义安全</h3><p><strong>语义安全性</strong>：语义安全性是第一个被提出的计算安全加密定义，它正式概念化了“攻击者无法从密文中获取任何关于明文的部分信息”这一概念。</p>
<p>通常，一个加密算法被认为是语义安全的，当且仅当它满足选择明文攻击（chosen-plaintext attack，CPA）的安全性。</p>
<blockquote>
<p>区分一下不同难度的攻击，从上到下难度递减：</p>
<ul>
<li><strong>唯密文攻击（COA）：</strong> <ul>
<li>条件：已知一个或多个密文</li>
<li>目标：确定明文</li>
</ul>
</li>
<li><strong>已知明文攻击（KPA）：</strong><ul>
<li>条件：已知一个或多个相同密钥加密的明-密文对</li>
<li>目标：确定其他密文对应的明文</li>
</ul>
</li>
<li><strong>选择明文攻击（CPA）：</strong><ul>
<li>条件：可以选择明文进行加密，并得到加密结果</li>
<li>目标：确定明文</li>
</ul>
</li>
<li><strong>选择密文攻击（CCA）：</strong><ul>
<li>条件：可以选择密文进行解密，并得到解密结果（通常不能对所要求的密文进行解密）</li>
<li>目标：确定所要求的密文对应的明文</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>下面再引出CPA安全和CCA安全的理解：</p>
<ul>
<li><strong>CPA安全：</strong> 针对加密方案而言，已知两个明文，对其中一个加密得到密文，攻击者无法很好地判断这个密文对应哪个明文。</li>
<li><strong>CCA安全：</strong> 针对加密方案而言，已知两个密文，对其中一个解密得到明文，攻击者无法很好地判断这个明文对应哪个密文。</li>
</ul>
</blockquote>
<ul>
<li><strong>语义安全</strong><br><strong>定义</strong>：一个私钥加密方案是语义安全的，如果对于任何ppt算法A，存在一个ppt算法$A_0$，使得对于任何ppt算法Samp和多项式时间可计算函数f和h，以下概率是可忽略的：<br>$Pr[A(1^n,Enck(m),h(m))&#x3D;f(m)]−Pr[A_0​(1^n,∣m∣,h(m))&#x3D;f(m)]$</li>
</ul>
<p><strong>语义安全的等价性：</strong><br>一个私钥加密方案在窃听者存在的情况下具有<strong>不可区分的加密</strong>当且仅当它是<strong>语义安全</strong>的。</p>
<blockquote>
<p><strong>语义安全</strong>与<strong>监听者存在下的不可区分性</strong>等价，但比不可区分性更为复杂和难以处理。</p>
</blockquote>
<h2 id="3-3-构建EAV安全加密方案"><a href="#3-3-构建EAV安全加密方案" class="headerlink" title="3.3 构建EAV安全加密方案"></a>3.3 构建EAV安全加密方案</h2><p>在构建EAV安全加密方案之前，先引入伪随机生成器，因为它通常用来生成加密密钥。</p>
<h3 id="3-3-1-伪随机生成器（PRG）"><a href="#3-3-1-伪随机生成器（PRG）" class="headerlink" title="3.3.1 伪随机生成器（PRG）"></a>3.3.1 伪随机生成器（PRG）</h3><p><strong>定义：</strong><br><strong>伪随机生成器</strong>是一个高效、确定性的算法，将一个较短的均匀随机字符串（seed）转换为更长的“看起来均匀”的字符串（伪随机字符串）</p>
<p>一个好的PRG应满足的条件：</p>
<ul>
<li>均匀性：输出的比特串应该足够均匀地分布在所有可能地比特串中</li>
<li>可预测性：在有seed的情况下可预测</li>
<li>不可区分性：在多项式时间内不能区分PRG输出和真正随机的输出</li>
</ul>
<blockquote>
<p>伪随机生成器G的输出并不是真正的均匀字符串</p>
</blockquote>
<p><strong>种子及长度：</strong><br>seed就类似加密方案中的密钥，必须<strong>均匀</strong>且必须<strong>足够长</strong>防止暴力攻击，还需要进行保密<br><strong>关于伪随机数的存在：</strong><br>虽然我们无法无条件地证明伪随机生成器的存在，但有理由相信它们存在。例如，如果单向函数存在，则可以构造伪随机生成器。<br><strong>实际构造</strong>：有许多实际的伪随机生成器（如流密码）被广泛使用，目前尚未发现有效的区分器。</p>
<h3 id="3-3-2-规约证明"><a href="#3-3-2-规约证明" class="headerlink" title="3.3.2 规约证明"></a>3.3.2 规约证明</h3><p>通常情况下，证明某个密码构造$Π$是安全的，只需要某个基础问题$X$是困难的，我们需要通过提供一个显式的规约来证明，该规约说明如何将任何成功“破解”$Π$的有效攻击者$A$转化为一个有效算法$A’$，该算法$A’$可以解决$X$。</p>
<blockquote>
<p>个人理解：就是将一个方案的安全性建立在某个困难问题上。</p>
</blockquote>
<h3 id="3-3-3-伪随机数生成器的EAV安全"><a href="#3-3-3-伪随机数生成器的EAV安全" class="headerlink" title="3.3.3 伪随机数生成器的EAV安全"></a>3.3.3 伪随机数生成器的EAV安全</h3><h4 id="加密方案"><a href="#加密方案" class="headerlink" title="加密方案"></a><strong>加密方案</strong></h4><ul>
<li><strong>构造</strong>：使用PRG G，其扩展因子为$l(n)$，构造一个固定长度的私钥加密方案。</li>
<li><strong>关键生成</strong>：$Gen(1^n)$输出一个均匀随机的n位种子k。</li>
<li><strong>加密</strong>：$Enc(k, m)$使用PRG G将种子k扩展为$l(n)$位的伪随机字符串，然后与明文m进行XOR得到密文c。</li>
<li><strong>解密</strong>：$Dec(k, c)$使用PRG G将种子k扩展为$l(n)$位的伪随机字符串，然后与密文c进行XOR得到明文m。</li>
</ul>
<h4 id="规约-讨论"><a href="#规约-讨论" class="headerlink" title="规约-讨论"></a><strong>规约-讨论</strong></h4><p><strong>目标</strong>：证明如果G是一个PRG，那么上述构造的加密方案是EAV-secure的。<br><strong>证明思路</strong>：通过归约证明，将攻击者A的成功概率与PRG G的伪随机性联系起来。</p>
<ul>
<li><strong>步骤1</strong>：固定一个攻击者A，其成功概率为$ε(n)$。</li>
<li><strong>步骤2</strong>：构造一个区分器D，它使用A来区分PRG G的输出和均匀随机字符串。</li>
<li><strong>步骤3</strong>：分析D的行为，证明如果G是PRG，那么D无法以非可忽略的概率区分G的输出和均匀随机字符串。</li>
<li><strong>步骤4</strong>：得出结论，A无法以非可忽略的概率成功攻击加密方案。</li>
</ul>
<h4 id="具体安全性"><a href="#具体安全性" class="headerlink" title="具体安全性"></a><strong>具体安全性</strong></h4><p>如果G是$(t, ε)-PRG$，那么加密方案是$(t - t_0, ε)-secure$，其中$t_0$是一个小的常数。<br>如果攻击者A在时间$t - t_0$内运行，那么D在时间$t$内运行。由于G是$(t, ε)-PRG$，D无法以超过$ε$的概率区分G的输出和均匀随机字符串，因此A无法以超过$ε$的概率成功攻击加密方案。</p>
<h2 id="3-4-更强的安全概念"><a href="#3-4-更强的安全概念" class="headerlink" title="3.4 更强的安全概念"></a>3.4 更强的安全概念</h2><h3 id="3-4-1-多次加密的安全性"><a href="#3-4-1-多次加密的安全性" class="headerlink" title="3.4.1 多次加密的安全性"></a>3.4.1 多次加密的安全性</h3><p>前面EAV安全只考虑了单个密文的安全性。<br><strong>多次加密安全定义：</strong><br><strong>实验定义</strong>：引入了一个新的实验$PrivK^{mult}_{A,Π}(n)$，用于评估加密方案在多消息场景下的安全性。</p>
<ol>
<li><strong>攻击者输出消息列表</strong>：攻击者A输出两组等长的消息列表$\vec M_0$和$\vec M_1$，每组包含t个消息，且每对消息$(m_0,i, m_1,i)$长度相同。</li>
<li><strong>密钥生成和加密</strong>：生成一个密钥k，随机选择一个比特b，对每组消息列表中的消息进行加密，得到密文列表$\vec C$。 </li>
<li><strong>攻击者猜测</strong>：攻击者A观察密文列表$\vec C$，并输出一个比特$b’$。</li>
<li><strong>实验结果</strong>：如果$b’ &#x3D; b$，则实验输出1，表示攻击者成功；否则输出0。</li>
</ol>
<h4 id="概率加密的必要性"><a href="#概率加密的必要性" class="headerlink" title="概率加密的必要性"></a><strong>概率加密的必要性</strong></h4><p>为了实现多次加密的安全性，加密方案必须引入随机性，使得即使加密相同的消息，也会产生不同的密文。</p>
<h4 id="流密码安全多次加密方案"><a href="#流密码安全多次加密方案" class="headerlink" title="流密码安全多次加密方案"></a>流密码安全多次加密方案</h4><p><strong>同步模式：</strong> 密钥流足够长，双方同步通讯，得知已使用过的密钥流的位数，去掉已使用过的位数，往后截取新的密钥进行使用<br><strong>非同步模式：</strong> 设置一个初始向量$IV$，生成密钥流时添入不同$IV$，保证每次生成的结果不一样。</p>
<h3 id="3-4-2-选择明文攻击和CPA安全性"><a href="#3-4-2-选择明文攻击和CPA安全性" class="headerlink" title="3.4.2 选择明文攻击和CPA安全性"></a>3.4.2 选择明文攻击和CPA安全性</h3><p><strong>定义</strong>：选择明文攻击是指攻击者能够选择某些明文，并观察这些明文被加密后的密文。这种攻击模拟了攻击者对加密过程的部分控制能力。</p>
<h4 id="CPA安全性"><a href="#CPA安全性" class="headerlink" title="CPA安全性"></a><strong>CPA安全性</strong></h4><p><strong>现代加密的最低要求</strong>：CPA安全性是现代加密方案应满足的最低安全要求。它确保即使攻击者能够选择某些明文并观察其密文，也无法获取关于其他未知消息的任何信息。<br><strong>更强的安全性</strong>：虽然CPA安全性是最低要求，但实际应用中通常需要更强的安全性。</p>
<h3 id="3-4-3-CPA安全性和多消息加密"><a href="#3-4-3-CPA安全性和多消息加密" class="headerlink" title="3.4.3 CPA安全性和多消息加密"></a>3.4.3 CPA安全性和多消息加密</h3><p><strong>等价性</strong>：如果一个加密方案能够抵抗单次加密的选择明文攻击，那么它也能够抵抗多消息加密的选择明文攻击</p>
<ul>
<li><strong>固定长度vs任意长度消息</strong><br><strong>构造方法：</strong> 将任意长度的消息拆分为各个固定长度的消息分别加密</li>
</ul>
<h2 id="3-5-构建一个CPA安全的加密方案"><a href="#3-5-构建一个CPA安全的加密方案" class="headerlink" title="3.5 构建一个CPA安全的加密方案"></a>3.5 构建一个CPA安全的加密方案</h2><h3 id="3-5-1-伪随机函数（PRFs）和置换"><a href="#3-5-1-伪随机函数（PRFs）和置换" class="headerlink" title="3.5.1 伪随机函数（PRFs）和置换"></a>3.5.1 伪随机函数（PRFs）和置换</h3><p>PRFs：伪随机函数是一种“看起来随机”的函数。与伪随机生成器类似，伪随机函数的安全性是通过其输出与真正随机函数的输出难以区分来定义的</p>
<ul>
<li><strong>伪随机函数和伪随机发生器</strong><br><strong>从PRF构造PRG</strong>：可以通过在一系列不同输入上评估PRF来构造PRG。例如，定义$G(s) &#x3D; F_s(1) || F_s(2) || … || F_s(l)$，其中$l$是所需的输出长度。<br><strong>从PRG构造PRF</strong>：可以将PRG的输出解释为一个查找表，从而构造一个PRF。但这种方法仅适用于小输入长度。</li>
</ul>
<blockquote>
<p>PRG要求输出长度必须大于输入长度，但PRF允许输出长度与输入无关</p>
</blockquote>
<h4 id="伪随机置换"><a href="#伪随机置换" class="headerlink" title="伪随机置换"></a>伪随机置换</h4><p><strong>定义：</strong> 伪随机置换是一种特殊的PRF，其中输入和输出长度相同，并且对于每个密钥k，$F_k$是一个双射（即置换）。</p>
<ul>
<li><strong>强伪随机置换</strong><br><strong>定义：</strong> 强伪随机置换不仅要求$F_k$与均匀随机置换不可区分，还要求即使区分器D同时访问$F_k$和其逆函数$F_k^{-1}$，也无法区分。</li>
</ul>
<h3 id="3-5-2-基于伪随机函数的CPA安全"><a href="#3-5-2-基于伪随机函数的CPA安全" class="headerlink" title="3.5.2 基于伪随机函数的CPA安全"></a>3.5.2 基于伪随机函数的CPA安全</h3><p>需要引入一个随机变量$r(如上边流密码非同步模式中的IV)$</p>
<h1 id="4-消息认证码（MAC）"><a href="#4-消息认证码（MAC）" class="headerlink" title="4.消息认证码（MAC）"></a>4.消息认证码（MAC）</h1><p>保证真实性和完整性</p>
<h2 id="4-1-消息完整性"><a href="#4-1-消息完整性" class="headerlink" title="4.1 消息完整性"></a>4.1 消息完整性</h2><h3 id="4-1-1-安全性vs完整性"><a href="#4-1-1-安全性vs完整性" class="headerlink" title="4.1.1 安全性vs完整性"></a>4.1.1 安全性vs完整性</h3><p><strong>保密性与完整性的区别</strong></p>
<ul>
<li><strong>保密性</strong>：通过加密技术防止被动窃听者获取通信内容。其目标是确保消息的内容不被未经授权的人知晓。</li>
<li><strong>完整性</strong>：确保消息在传输过程中未被篡改或伪造。这不仅涉及消息内容的正确性，还涉及消息来源的真实性</li>
</ul>
<h3 id="4-1-2-加密与消息认证"><a href="#4-1-2-加密与消息认证" class="headerlink" title="4.1.2 加密与消息认证"></a>4.1.2 加密与消息认证</h3><p> <strong>加密与消息认证的区别</strong> </p>
<ul>
<li><strong>加密</strong>：用于实现保密性，即防止未经授权的第三方获取消息内容。   </li>
<li><strong>消息认证</strong>：用于保证消息的完整性和来源的真实性，确保消息未被篡改且确实来自声称的发送者。</li>
</ul>
<p><strong>常见误区</strong>：许多人错误地认为加密可以自动提供消息认证，但实际上加密并不保证消息的完整性，除非它被专门设计为具有此功能。</p>
<ul>
<li><p><strong>使用流密码加密</strong><br><strong>流密码加密机制</strong>：使用共享密钥生成伪随机序列（pad），然后通过与明文进行异或运算生成密文。<br><strong>漏洞分析</strong>：流密码加密的密文很容易被篡改。攻击者可以通过翻转密文中的任意一位来翻转解密后明文中的对应位。例如：<br>如果用户加密了一个表示转账金额的数字（如1000美元），攻击者可以通过翻转最低位来改变金额为1001美元，或者通过翻转第11位来增加超过1000美元。<br>即使攻击者不知道具体的金额，但如果有部分先验知识（如金额小于1000美元），他们可以预测修改的效果。<br><strong>结论</strong>：这种攻击并不违反加密的保密性，但它严重破坏了消息的完整性。</p>
</li>
<li><p><strong>使用分组密码加密</strong><br><strong>分组密码加密机制</strong>：使用分组密码（如AES）对数据块进行加密。<br><strong>漏洞分析</strong>：<br><strong>ECB模式</strong>：翻转密文中某个数据块的某一位只会改变解密后该数据块的对应位，其他数据块保持不变。虽然对单个数据块的影响可能难以预测，但这种局部篡改可能已经足够造成损害。此外，攻击者可以通过重新排列密文块来重新排列明文块，或者通过丢弃密文块来截断消息。<br><strong>CBC模式</strong>：攻击者可以通过翻转$IV$的某一位来改变第一个明文块的对应位，而其他明文块保持不变。<br><strong>结论</strong>：即使使用更复杂的分组密码加密模式，攻击者仍然可以通过对密文进行局部修改来实现对明文的篡改。</p>
</li>
</ul>
<h2 id="4-2-MAC定义"><a href="#4-2-MAC定义" class="headerlink" title="4.2 MAC定义"></a>4.2 MAC定义</h2><p>MAC的目的是防止对手修改一方发送给另一方的消息，或注入新消息，而接收方无法察觉消息并非来自预期的发送方</p>
<p><strong>MAC的两个典型应用场景</strong></p>
<ul>
<li>确保两方通信时的完整性（如用户与银行之间的通信）</li>
<li>或一个用户随时间“与自己”通信（如涉及网络Cookie的情况，或用户保护其硬盘内容的情况）</li>
</ul>
<h4 id="消息认证码的语法"><a href="#消息认证码的语法" class="headerlink" title="消息认证码的语法"></a>消息认证码的语法</h4><p><strong>密钥生成算法 Gen</strong>：输入安全参数$1^n$，输出密钥 k，且$∣k∣≥n$。<br><strong>标签生成算法 Mac</strong>：输入密钥 k 和消息 m，输出标签 t。<br><strong>验证算法 Vrfy</strong>：输入密钥 k、消息 m 和标签 t，输出验证结果（1 表示有效，0 表示无效）。</p>
<p><strong>要求</strong>：对于所有密钥 k 和消息 m，必须满足$Vrfy_k​(m,Mack​(m))&#x3D;1$。</p>
<ul>
<li><strong>规范验证</strong><br>对于确定性的MAC，进行验证的规范方法：<br>重新计算标签并检查其是否相等。换句话说，$Vrfy_k（m，t）$首先计算$\bar t：&#x3D;Mack(m)$，然后输出1当且仅当$\tilde t&#x3D;t$。</li>
</ul>
<h4 id="MAC安全"><a href="#MAC安全" class="headerlink" title="MAC安全"></a>MAC安全</h4><p><strong>两个定义假设：</strong></p>
<ol>
<li>攻击者可以反复请求其选择的任何消息的标签。</li>
<li>如果攻击者能够为任何之前未认证的消息生成有效标签，则认为方案被破解。</li>
</ol>
<p>如果无法被上述方式破解，那么MAC被称为在自适应选择消息攻击下存在性不可伪造的。</p>
<ul>
<li><p><strong>定义是否过于严格？</strong><br>有人提议说定义安全性时只关注<strong>有效消息</strong>就可以，但在实际中，是否有效取决于具体情况，只有严格的定义才能适应更广泛的情况。</p>
</li>
<li><p><strong>重播攻击</strong><br>攻击者简单地重新发送之前已认证的消息及其有效标签。MAC本身无法防止这种攻击，因为验证过程是无状态的（即每次呈现有效的消息和标签对时，验证算法总是输出1）。<br>防止方法：序列号、时间戳</p>
</li>
<li><p><strong>强不可伪造性</strong><br>要求攻击者无法为任何消息生成新的有效标签，即使该消息之前已被认证过。</p>
</li>
<li><p><strong>验证查询</strong><br>这些定义中的攻击者被赋予对MAC预言机的访问权限，这对应于现实世界中能够影响诚实发送方为某些消息生成标签的攻击者。</p>
</li>
<li><p><strong>潜在的定时攻击</strong><br>一种测信道攻击：它需要访问验证预言机以及测量比较i和i+ 1字节所需时间差异的能力。</p>
</li>
</ul>
<h1 id="5-选择密文攻击-CCA-安全和认证加密"><a href="#5-选择密文攻击-CCA-安全和认证加密" class="headerlink" title="5.选择密文攻击(CCA)安全和认证加密"></a>5.选择密文攻击(CCA)安全和认证加密</h1><p><strong>概念</strong>：攻击者选择密文让接收者解密。<br><strong>简单举例</strong>：战争中，美军曾向日军透露包含AF的加密信息，通过日军的反应，可以猜测AF所代表的明文是什么。</p>
<p>攻击常发生在Web服务器上，用来获取TLS会话内容</p>
<h2 id="5-2Padding-Oracle-Attacks（填充提示攻击）"><a href="#5-2Padding-Oracle-Attacks（填充提示攻击）" class="headerlink" title="5.2Padding-Oracle Attacks（填充提示攻击）"></a>5.2Padding-Oracle Attacks（填充提示攻击）</h2><ul>
<li><strong>常用填充方式PKCS #7</strong>:<br>设分组密码的分组长度为L，若密文差b个字节达到L的整数倍，那么便填充b个值为b的十六进制数<br>如：差4个字节就填充0x04040404<br>如果b等于0，那么便令b为L，即$b\in [1,L]$<br><strong>验证方法：</strong> 先读取最后一个字节的值b，再判断最后b个值是否都为b。</li>
</ul>
<h3 id="攻击方法：-CBC模式"><a href="#攻击方法：-CBC模式" class="headerlink" title="攻击方法：(CBC模式)"></a><strong>攻击方法：(CBC模式)</strong></h3><p>已知：$IV,c_1,c_2$<br><strong>1.求b：</strong><br>先修改最后一个块的第一个字节，如果报错，说明b&#x3D;L,，否则b&lt;L，接着修改下一个字节，重复此过程便能求出b。<br><strong>2.求除填充外的最后一个明文字节：</strong> </p>
<ul>
<li>设$i\in[0,2^8),$取一个<br>$\Delta i$<br>$&#x3D;0x00,…,0x00,0xi, 0x(b+1),…,0x(b+1)$<br>$\oplus,0x00,…,0x00,0x00,0xb,…,0xb$<blockquote>
<p>ps:$0xi$后跟的是b个0xb+1</p>
</blockquote>
</li>
<li>取$c_1’&#x3D;c_1\oplus \Delta i$，将$IV,c_1’,c_2$送给解密服务器</li>
<li>遍历$i$，知道服务器返回解密成功，此时的$m_2$明文形式为：<br>$m_2&#x3D;…;0x(b+1);0x(b+1);…;0x(b+1)$，共$b+1$个$0x(b+1)$</li>
<li>设最后一个明文非填充字节为M，则有$0x(b+1)&#x3D;M\oplus i$</li>
<li>得到$M&#x3D;i\oplus 0x(b+1)$</li>
<li>以此类推便可以求出所有明文字节，据我理解，求$m_1$时可以去掉$c_2$，将b最开始当作0，将$c_1,IV$发送给解密服务器。</li>
</ul>
<h3 id="验证码攻击"><a href="#验证码攻击" class="headerlink" title="验证码攻击"></a>验证码攻击</h3><ul>
<li>Web服务器$S_w$（生成密文），验证码服务器$S_c$（生成验证码），两服务器共享密钥，用户$u$<br><strong>正常过程：</strong> $S_w$生成密文发送给用户$u，u$将其发送给$S_c$，$S_c$会对填充错误的密文返回错误，让$S_c$生成扭曲的验证码返回$u，u$通过查看验证码得到明文$m$，发送给$Sw$，验证通过<br><strong>攻击过程：</strong> $S_w$行为不变，$u$使用Padding Oracle Attacks去攻击$S_c$，最后得到明文$m$，此时自动脚本也能完成人机验证。</li>
</ul>
<h3 id="CCA安全性定义"><a href="#CCA安全性定义" class="headerlink" title="CCA安全性定义"></a>CCA安全性定义</h3><p><strong>威胁模型：</strong></p>
<ul>
<li>拥有加密预言机（黑盒，密钥随机），解密预言机，但对给定密文没有解密权限。（一般是最坏假设）<br><strong>安全目标：</strong></li>
<li>给定攻击者一个密文$c$，若他能以显著大于$\frac12$的概率判断是$m_0,m_1$中的哪个的加密结果，则方案不安全。</li>
</ul>
<h2 id="5-2认证加密（AE）"><a href="#5-2认证加密（AE）" class="headerlink" title="5.2认证加密（AE）"></a>5.2认证加密（AE）</h2><p><strong>目标：</strong> 保密性，完整性<br>保密性：CCA安全<br>完整性：不可伪造性<br><strong>定义</strong>：如果一个私钥加密方案既是CCA安全的，又是不可伪造的，则它是一个认证加密（AE）方案。</p>
<h1 id="6-哈希函数和应用"><a href="#6-哈希函数和应用" class="headerlink" title="6.哈希函数和应用"></a>6.哈希函数和应用</h1><p><strong>概念：</strong> 一种将长输入字符串映射到短输出字符串（摘要）的函数。<br><strong>碰撞：</strong> 两个不同输入产生相同摘要。<br><strong>抗碰撞性：</strong> 任何概率多项式时间算法都难以找到H中的碰撞。<br><strong>带密钥的hash函数：</strong> 此时函数H有两个输入，$key:s,string:x$，输出为$H^s&#x3D;H(s,x)$。其中$s$在上标是为了说明，$s$不是保密的，即使对手获得了$s$，函数H仍然具有抗碰撞性。</p>
<blockquote>
<p>实际应用中基本上还是使用不带密钥的hash函数。</p>
</blockquote>
<p><strong>第二原像抗碰撞性：</strong> 已知H和x，ppt对手难以找到$x_1\neq x$，使$H^s(x_1)&#x3D;H^s(x)$</p>
<blockquote>
<p>抗碰撞性的hash函数也是抗第二原像碰撞的，抗第二原像碰撞的也是抗原像碰撞的。</p>
</blockquote>
<p><strong>原像抗性：</strong> 已知H和y（y&#x3D;H(x)），ppt对手能找到一个$x_1$（无论是否等于x）使得$H^s(x_1)&#x3D;y$。</p>
<blockquote>
<p>原像抗性基本上意味着$H^s$的单向性。</p>
</blockquote>
<h2 id="6-2The-Merkle-Damgard-Transform"><a href="#6-2The-Merkle-Damgard-Transform" class="headerlink" title="6.2The Merkle-Damgard Transform"></a>6.2The Merkle-Damgard Transform</h2><p><strong>简要：</strong> $Merkle-Damgard$变换，即MD变换，是一种将定长哈希函数转换成全功能（可变长度）哈希函数的技术。<br><strong>定长哈希</strong>：MD5、SHA-256等。<br><img src="/2025/04/28/Introduction%20To%20Modern%20Cryptography%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/file-20250422161507480.png" srcset="/img/loading.gif" lazyload><br><strong>变换步骤</strong>：</p>
<ul>
<li>将数据分割成多个固定大小的块，每个块大小通常等于定长哈希函数的长度</li>
<li>设置$IV$</li>
<li>对每个块进行压缩。（使用定长hash函数将前一个压缩结果和当前块进行压缩）</li>
<li>最后得到的最后一个压缩输出便是该全功能hash函数的输出</li>
</ul>
<h2 id="6-3-Hash-and-MAC和HMAC"><a href="#6-3-Hash-and-MAC和HMAC" class="headerlink" title="6.3 Hash-and-MAC和HMAC"></a>6.3 Hash-and-MAC和HMAC</h2><h3 id="6-3-1-Hash-and-MAC"><a href="#6-3-1-Hash-and-MAC" class="headerlink" title="6.3.1 Hash-and-MAC"></a>6.3.1 Hash-and-MAC</h3><p><strong>实现：</strong> 首先使用Hash函数对消息进行摘要，然后使用密钥对哈希值进行签名，得到MAC</p>
<p><strong>特点：</strong></p>
<ul>
<li>简单高效</li>
<li>安全可靠<br><strong>限制：</strong></li>
<li>密钥管理</li>
<li>单向性</li>
</ul>
<h3 id="6-3-2-HMAC"><a href="#6-3-2-HMAC" class="headerlink" title="6.3.2 HMAC"></a>6.3.2 HMAC</h3><p>使用hash运算的消息认证码MAC<br><strong>构造：</strong></p>
<ul>
<li>对密钥进行预处理，使其与哈希函数的输入长度相同（通常是哈希函数的块长度）。</li>
<li>将经过预处理的密钥与消息进行异或运算，得到新的输入。</li>
<li>对新的输入使用哈希函数进行多轮迭代计算，得到消息认证码。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>安全性高</li>
<li>灵活性强</li>
</ul>
<h3 id="6-4-1-生日攻击"><a href="#6-4-1-生日攻击" class="headerlink" title="6.4.1 生日攻击"></a>6.4.1 生日攻击</h3><p><strong>介绍：</strong> 在一个大小为N的输出空间中，遍历$\Theta(\sqrt N)$时找到碰撞的概率为$\frac12$左右。</p>
<blockquote>
<p>若$N&#x3D;2^l$，则$\Theta(\sqrt N)&#x3D;\Theta(2^{\frac12})$</p>
</blockquote>
<h4 id="有意义碰撞："><a href="#有意义碰撞：" class="headerlink" title="有意义碰撞："></a><strong>有意义碰撞：</strong></h4><p>条件同上，遍历两组$\Theta(2^{\frac12})$的不同消息。<br>两组消息存在碰撞的概率也为$\frac12$左右。</p>
<h3 id="6-4-2-小空间生日攻击"><a href="#6-4-2-小空间生日攻击" class="headerlink" title="6.4.2 小空间生日攻击"></a>6.4.2 小空间生日攻击</h3><p>使用Floyd循环查找算法，使成功概率和运行时间与原版大致相同，但只需常数内存。</p>
<blockquote>
<p>如果练过算法题，应该会知道<strong>快慢指针法</strong>，其实本质是一样的，慢指针做一次运算，慢指针做两次运算，如果有循环，总会相遇。</p>
</blockquote>
<p><strong>步骤：</strong> </p>
<ul>
<li>首先选择一个随机的消息$x_0$，赋值$x:&#x3D;x_0,x’:&#x3D;x_0$</li>
<li>在第$i$次迭代时比较$x_i&#x3D;H(x_{i-1})和x_i’&#x3D;H(H(x_{i-1}’))$的值</li>
<li>如果$x_i &#x3D; x_i’$，说明发生了冲突。</li>
<li>（直接碰撞）且如果$x_{i-1}\neq H(x_{i-1}’)$，则冲突对为$x_{i-1}\neq H(x_{i-1}’)$</li>
<li>（间接碰撞）而如果$x_{i-1} &#x3D; H(x_{i-1}’)$，则说明碰撞可能发生在更早的步骤中。但由于hash值没有被记录，因此还需要再次迭代</li>
<li>存储找到的编号$i$，并将$x&#x3D;x_0,x’&#x3D;x_0$，重置初始值为$x_0$</li>
<li>迭代到$i$,在每一步$j$中，检查$H(x_j)&#x3D;H(x_j’)$</li>
<li>若找到，则找到了碰撞，返回$x_j$和$x_j’$</li>
<li>否则，令$x_j&#x3D;H(x_j)$和$x_j’&#x3D;H(x_j’)$<br><strong>代码实现:</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">random_binary_string</span>(<span class="hljs-params">length = <span class="hljs-number">16</span></span>):<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(random.choice(<span class="hljs-string">&#x27;01&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">H</span>(<span class="hljs-params">x</span>):<br>	<span class="hljs-keyword">return</span> hashlib.sha256(x.encode()).hexdigest()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">SmallSpaceBirthdayAttack</span>():<br>	x_0 = random_binary_string()<br>	x = x_0<br>	x_1 = x_0<br>	i = <span class="hljs-number">0</span><br><br>	<span class="hljs-comment">#寻找碰撞</span><br>	<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<br>		x = H(x)<br>		x_1 = H(H(x_1))<br><br>		<span class="hljs-keyword">if</span> x == x_1:<br>			<span class="hljs-keyword">break</span><br>		<span class="hljs-keyword">else</span>:<br>			i += <span class="hljs-number">1</span><br><br>	<span class="hljs-comment">#回溯，寻找具体碰撞点</span><br>	x = x_0<br>	x_1 = x_0<br><br>	<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>		<span class="hljs-keyword">if</span> H(x) == H(x_1):<br>			<span class="hljs-keyword">return</span> (x,x_1)<br>		<span class="hljs-keyword">else</span>:<br>			x = H(x)<br>			x_1 = H(x_1)<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>ans = SmallSpaceBirthdayAttack()<br><span class="hljs-keyword">if</span> ans:<br>	<span class="hljs-built_in">print</span>(ans)<br><span class="hljs-keyword">else</span>:<br>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO！！！&quot;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="有意义碰撞"><a href="#有意义碰撞" class="headerlink" title="有意义碰撞"></a>有意义碰撞</h4><p><strong>实现思想：</strong> 将两个类型不同的可选择句子映射为二进制，便可以使用上边的算法<br><strong>映射方法：</strong> 例如找两个语义相反的句子，<br>$type 0: Alice is a good&#x2F;great and honest&#x2F;trustworthy worker&#x2F;employee.$<br>$type 1: Alice is a bad&#x2F;lousy and annoying&#x2F;irritating worker&#x2F;employee.$<br>将类型0&#x2F;1映射到二进制的首数字，剩下的按照每个类型中的每个可选单词是选的第一个还是第二个来映射，如<br>$g(0000) &#x3D; Alice is a good and honest worker.$<br>$g(1101) &#x3D; Alice is a lousy and annoying employee.$</p>
<h3 id="6-4-3-时空折中攻击（Hellman’s-time-space-tradeoff-）"><a href="#6-4-3-时空折中攻击（Hellman’s-time-space-tradeoff-）" class="headerlink" title="6.4.3 时空折中攻击（Hellman’s time&#x2F;space tradeoff.）"></a>6.4.3 时空折中攻击（Hellman’s time&#x2F;space tradeoff.）</h3><p><strong>时间&#x2F;空间折中</strong>：通过预处理和存储，可以在存储空间和计算时间之间进行权衡，从而在合理的时间和空间复杂度内找到哈希函数的预像。</p>
<h4 id="Hellman-的时间-空间折中"><a href="#Hellman-的时间-空间折中" class="headerlink" title="Hellman 的时间&#x2F;空间折中"></a>Hellman 的时间&#x2F;空间折中</h4><p><strong>方法</strong>：Hellman 提出了一种更通用的时间&#x2F;空间权衡方法，适用于任意函数H。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li><p><strong>选择参数</strong>：选择参数$s$和$t$。</p>
</li>
<li><p><strong>生成表</strong>：选择$s$个均匀随机的起始点$SP_1​,…,SP_s​∈{0,1}^ℓ$。对于每个起始点$SP_i$​，计算对应的终点$EPi​:&#x3D;H^{(t)}(SP_i​)（即H的t次迭代）$。</p>
</li>
<li><p><strong>存储</strong>：将所有对$(SP_i​,EP_i​)$存储在表中，按终点排序。</p>
</li>
<li><p><strong>在线阶段</strong>：给定$y$，检查$y,H(y),…,H^{(t−1)}(y)$是否与表中的某个终点匹配。如果找到匹配，则计算$H^{(t−j−1)}(SP_i​)$并检查是否为$y$的原像。</p>
</li>
</ol>
<h1 id="9-数论与密码困难假设"><a href="#9-数论与密码困难假设" class="headerlink" title="9.数论与密码困难假设"></a>9.数论与密码困难假设</h1><h3 id="9-1-1质数和可除性"><a href="#9-1-1质数和可除性" class="headerlink" title="9.1.1质数和可除性"></a>9.1.1质数和可除性</h3><p><strong>命题1：</strong> 对正整数a，b，有唯一q，r满足$a&#x3D;qb+r$，其中$r\in[0,b)$<br><strong>命题2：</strong> 正整数a，b，存在整数X，Y，满足$Xa+Yb&#x3D;gcd（a，b）$，其中$gcd(a,b)$是这种形式能够表示的最小正整数。<br><strong>命题3：</strong> 如果$c|ab，gcd(a,c)&#x3D;1$，则有$c|b$<br><strong>命题4：</strong> 如果$a|N,b|N,并且gcd(a,b)&#x3D;1，则ab|N$</p>
<h3 id="9-1-2模运算"><a href="#9-1-2模运算" class="headerlink" title="9.1.2模运算"></a>9.1.2模运算</h3><p><strong>命题：</strong> 对整数b，N，其中$b\geq 1$并且$N&gt;1$。当且仅当$gcd(b,N)&#x3D;1$时b关于N可逆。</p>
<h3 id="9-1-3群"><a href="#9-1-3群" class="headerlink" title="9.1.3群"></a>9.1.3群</h3><p><strong>定义：</strong> 群是由集合G和二元运算$\circ$组成。</p>
<ul>
<li><strong>闭合性：</strong> 对于g，h$\in G$，$g\circ h \in G$</li>
<li><strong>存在单位元：</strong> 存在e，使$e\circ g &#x3D; g &#x3D; g\circ e$</li>
<li><strong>存在逆元：</strong> 存在h，使得$g\circ h &#x3D; h\circ g &#x3D; e$</li>
<li><strong>结合性：</strong> $(g_1\circ g_2)\circ g_3 &#x3D; g_1 \circ (g_2 \circ g_3)$<br>阶：若元素数有限，称群为有限群，用|G|表示群的阶。<br><strong>Abelian群：</strong> 具有<strong>交换性</strong>，即满足$g\circ h &#x3D; h\circ g$的群。<br><strong>子群：</strong> 如果群$H\subseteq G$ ，且H与G运算相同，则H是G的子群。<br><strong>平凡子群：</strong> G或{1}（类比平凡因子）</li>
</ul>
<p><strong>定理：</strong> 已知$N&#x3D;\Pi_ip_i^{e_i}，其中e_i\geq 1$，则有$\phi(N)&#x3D;\Pi_ip_i^{e_i-1}(p_i-1)$</p>
<h3 id="9-1-4-乘法群：欧拉函数"><a href="#9-1-4-乘法群：欧拉函数" class="headerlink" title="9.1.4 乘法群：欧拉函数"></a>9.1.4 乘法群：欧拉函数</h3><p><strong>定理：</strong> 设$N&gt;1$是一个整数。那么$Z^*_N$是关于模$N$的乘法运算的一个阿贝尔群。<br><strong>定理：</strong> 设$N&#x3D;\Pi _ip_i^{e_i}$，其中${p_i}$是不同的素数，$e_i\geq 1$。那么$\Phi(N)&#x3D;\Pi _ip_i^{e_i-1}(p_i-1)$</p>
<p><strong>推论：</strong> 取任意整数$N&gt;1$和$a\in Z^*_N$。则$a^{\Phi(N)}&#x3D;1 \mod N$</p>
<h3 id="9-1-5中国剩余定理（CRT）"><a href="#9-1-5中国剩余定理（CRT）" class="headerlink" title="9.1.5中国剩余定理（CRT）"></a>9.1.5中国剩余定理（CRT）</h3><p>已知N&#x3D;pq，求$x\mod m$，令$m_1m_2&#x3D;M$<br>$x\equiv a \mod m_1$<br>$x\equiv b \mod m_2$<br><strong>求解过程：</strong> </p>
<ul>
<li>求$M_1，M_2$，其中$M_1&#x3D;\frac{M}{m_1}M_2&#x3D;\frac{M}{m_2}$</li>
<li>求$M_1^{-1},M_2^{-1}$，其中$M_1^{-1}\equiv M_1 \mod m_1，M_2^{-1}$同理</li>
<li>求$x\equiv aM_1M_1^{-1}+bM_2M_2^{-1} \mod M$</li>
</ul>
<h2 id="9-2-素数、分解、RSA"><a href="#9-2-素数、分解、RSA" class="headerlink" title="9.2 素数、分解、RSA"></a>9.2 素数、分解、RSA</h2><h3 id="9-2-1-生成随机素数"><a href="#9-2-1-生成随机素数" class="headerlink" title="9.2.1 生成随机素数"></a>9.2.1 生成随机素数</h3><p><strong>算法构造</strong>：<br>从1到$3n^2$进行循环：</p>
<ul>
<li>随机选择一个n-1位的二进制数$p_0$</li>
<li>将最高位设为1，得到n位数p</li>
<li>进行Miller-Rabin测试，输入为p和参数$1^n$</li>
<li>如果输出是”素数“，则返回p<br>如果再尝试$3n^2$次后没有找到素数，则返回失败。</li>
</ul>
<h3 id="9-2-2-素性测试"><a href="#9-2-2-素性测试" class="headerlink" title="9.2.2 素性测试"></a>9.2.2 素性测试</h3><h4 id="Miller-Rabin-素性测试"><a href="#Miller-Rabin-素性测试" class="headerlink" title="Miller-Rabin 素性测试"></a><strong>Miller-Rabin 素性测试</strong></h4><p><strong>介绍：</strong> 基于费马小定理和二次探测定理的随机化算法<br><strong>二次探测定理：</strong> 对于素数p，若$x^2\equiv 1 \mod p$，则小于p的解只有两个，$x_1&#x3D;1,x_2&#x3D;p-1$<br><strong>步骤：</strong></p>
<ul>
<li>令$n-1&#x3D;2^kq$，其中$k&gt;0,q$为奇数，随机选取整数$a,1&lt;a&lt;n-1$</li>
<li>若$a^q\mod n&#x3D;1$，则n有可能是素数</li>
<li>取整数$j$，$0\geq j &lt; k$，若存在$a^{2^j}\mod n &#x3D; n -1$，则n有可能是素数；否则，n为合数</li>
</ul>
<p><strong>定理：</strong> 如果N是奇数，且不是素数的幂，那么在$Z^*_N$中，至少有一半的元素是N是合数的强见证。</p>
<h3 id="9-2-3-分解假设"><a href="#9-2-3-分解假设" class="headerlink" title="9.2.3 分解假设"></a>9.2.3 分解假设</h3><p>因式分解假设是指存在一个相对的GenModulus，使得因式分解变得困难，其中GenModulus是一个用来生成$(N,p,q)$多项式时间算法</p>
<h3 id="9-2-4-RSA假设"><a href="#9-2-4-RSA假设" class="headerlink" title="9.2.4 RSA假设"></a>9.2.4 RSA假设</h3><p>假设存在一个GenRSA算法，使得RSA问题在多项式时间内难以解决。这一假设是RSA公钥密码学安全性的基础。<br><strong>e的选择：</strong> 最常见的选择为65537，像是e&#x3D;3等容易遭受低加密指数攻击</p>
<h2 id="9-3循环群中的密码学假设"><a href="#9-3循环群中的密码学假设" class="headerlink" title="9.3循环群中的密码学假设"></a>9.3循环群中的密码学假设</h2><h3 id="9-3-1循环群和生成元"><a href="#9-3-1循环群和生成元" class="headerlink" title="9.3.1循环群和生成元"></a>9.3.1循环群和生成元</h3><p><strong>命题9.55：</strong> 设G是一个阶为 m 的有限群，且$g\in G$的阶为i，则$i|m$<br><strong>推论9.56：</strong> G是一个阶为素数p的群，则G是循环群。且G中除了单位元之外所有元素都是生成元。<br><strong>定理9.57：</strong> 如果p是一个素数，那么$Z_p^*$是一个阶为p-1的循环群</p>
<h3 id="9-3-2离散对数-Diffie-Hellman假设"><a href="#9-3-2离散对数-Diffie-Hellman假设" class="headerlink" title="9.3.2离散对数&#x2F;Diffie-Hellman假设"></a>9.3.2离散对数&#x2F;Diffie-Hellman假设</h3><p><strong>离散对数问题：</strong> 在一个循环群$G$中，给定群的生成元$g$和一个群元素$h$，求解整数$x$，使得$g^x&#x3D;h$</p>
<blockquote>
<p>当群的阶数较大时，这是一个十分困难的问题</p>
</blockquote>
<p><strong>Diffie-Hellman问题：</strong></p>
<ul>
<li>计算Diffie-Hellman问题（CDH）：给定$h_1&#x3D;g^{x_1}和h_2&#x3D;g^{x_2}$，计算$g^{x_1x_2}$</li>
<li>决策Diffie-Hellman问题（DDH）：给定$h_1&#x3D;g^{x_1}和h_2&#x3D;g^{x_2}和h_0$和，判断$h_0和g^{x_1x_2}是否相等$</li>
</ul>
<h4 id="使用素数阶群"><a href="#使用素数阶群" class="headerlink" title="使用素数阶群"></a>使用素数阶群</h4><p><strong>原因：</strong> 离散对数问题在这种群中最为困难</p>
<h3 id="9-3-3-Z-p-的子群"><a href="#9-3-3-Z-p-的子群" class="headerlink" title="9.3.3 $Z_p^*$的子群"></a>9.3.3 $Z_p^*$的子群</h3><p><strong>定理9.66：</strong> 令p&#x3D;rq+1，其中p，q为素数。则有<br>$$ G&#x3D;{[h^r\mod p]h\in Z_p^*} $$</p>
<p>是一个$Z_p^*$的q阶子群。</p>
<h3 id="9-3-4椭圆曲线"><a href="#9-3-4椭圆曲线" class="headerlink" title="9.3.4椭圆曲线"></a>9.3.4椭圆曲线</h3><p><strong>常规表示（Weierstrass表示）：</strong></p>
<p>$$ y^2&#x3D;x^3+Ax+B \mod p $$</p>
<p>不同曲线的计算方法不一样</p>
<h4 id="Montgomery表示"><a href="#Montgomery表示" class="headerlink" title="Montgomery表示"></a>Montgomery表示</h4><p>$$By^2&#x3D;x^3+Ax^2+x \mod p$$<br>其中，$B\neq0\mod p且A\equiv ±2\mod p$<br><strong>相比Weierstrass形式的优势：</strong> 蒙哥马利表示在某些情况下比魏尔斯特拉斯表示更高效，特别是在实现级安全性（如抵抗侧信道攻击）方面。</p>
<h4 id="（Twisted-Edwards表示"><a href="#（Twisted-Edwards表示" class="headerlink" title="（Twisted) Edwards表示"></a>（Twisted) Edwards表示</h4><p>$$ ax^2+y^2&#x3D;1+dx^2y^2 \mod p $$<br><strong>命题9.7：</strong> p是$\geq 5$的素数，E是曲线$y^2&#x3D;x^3+Ax+B \mod p$</p>
<h4 id="选择椭圆曲线群"><a href="#选择椭圆曲线群" class="headerlink" title="选择椭圆曲线群"></a>选择椭圆曲线群</h4><h4 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h4><h5 id="1-点压缩"><a href="#1-点压缩" class="headerlink" title="1.点压缩"></a>1.点压缩</h5><p>在椭圆曲线中，一个点通常由两个坐标$（x, y）$表示。为了减少表示点所需的比特数，可以使用点压缩技术。</p>
<h5 id="2-射影坐标"><a href="#2-射影坐标" class="headerlink" title="2.射影坐标"></a>2.射影坐标</h5><p><strong>仿射坐标</strong>：点P在椭圆曲线上的表示形式为 $(x, y)$。<br><strong>射影坐标</strong>：点P在射影坐标中的表示形式为 $(X, Y, Z)$，满足$X&#x2F;Z&#x3D;xmodp$和 $Y&#x2F;Z&#x3D;y\mod p$。</p>
<ul>
<li><strong>无穷远点O</strong>：在射影坐标中表示为$(0, Y, 0)$，其中$Y\neq0$。</li>
<li><strong>转换</strong>：从仿射坐标$(x, y)$转换为射影坐标$(x, y, 1)$；从射影坐标$(X, Y, Z)$转换为仿射坐标$(X&#x2F;Z\mod p,Y&#x2F;Z\mod p)$。<br><strong>优势：</strong> 在射影坐标中，点的加法操作不需要计算模p的逆元。计算逆元的代价较高，而加法和乘法的代价较低</li>
</ul>
<h5 id="3-常用椭圆曲线"><a href="#3-常用椭圆曲线" class="headerlink" title="3.常用椭圆曲线"></a>3.常用椭圆曲线</h5><ul>
<li><strong>P-256(secp256r1)：</strong> 定义在256位素数$p&#x3D;2^{256}-2^{224}+2^{192}+2^{96}-1$上<br>$y^2&#x3D;x^3-3x+B \mod p$，其中$B$是特定常数</li>
<li><strong>P-384和P-521：</strong> 与P-256类似，p分别为384位和521位素数</li>
<li><strong>Curve25519：</strong> 定义在素数$p&#x3D;2^{255}-19$上<br>可以用蒙哥马利形式表示，也可以用扭曲爱德华兹形式表示（称为Ed25519）。</li>
<li><strong>secp256k1：</strong> 定义在素数$p&#x3D;2^{256}-2^{32}-2^9-2^8-2^7-2^6-2^4-1$<br>是一条Koblitz曲线，方程为$y^2&#x3D;x^3+7\mod p$</li>
</ul>
<h1 id="11-密钥管理和公钥革命"><a href="#11-密钥管理和公钥革命" class="headerlink" title="11.密钥管理和公钥革命"></a>11.密钥管理和公钥革命</h1><h2 id="11-1密钥分配和密钥管理"><a href="#11-1密钥分配和密钥管理" class="headerlink" title="11.1密钥分配和密钥管理"></a>11.1密钥分配和密钥管理</h2><p>私钥加密三个问题：</p>
<ul>
<li>密钥分配</li>
<li>存储和管理大量密钥：一个典型的解决方案是将密钥存储在安全硬件上</li>
<li>私钥加密在开放系统中的不适用性</li>
</ul>
<h2 id="11-2部分解决方案：密钥分配中心（KDC）"><a href="#11-2部分解决方案：密钥分配中心（KDC）" class="headerlink" title="11.2部分解决方案：密钥分配中心（KDC）"></a>11.2部分解决方案：密钥分配中心（KDC）</h2><p>找一个守信任的实体充当KDC，帮助所有员工共享成对密钥<br><strong>优点：</strong></p>
<ul>
<li>每个员工只需要存储一个长期密钥（与KDC共享）。（KDC需要存储许多长期密钥，但可以集中放在安全的地方）</li>
<li>新员工加入时，只需要新员工和KDC之间更新密钥。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对KDC的成功攻击会导致系统完全崩溃。</li>
<li>KDC是一个单点故障，如果宕机，安全通信将暂时无法实现，负载较高。（一种解决方法是复制更多的KDC）</li>
</ul>
<h3 id="使用KDC进行密钥分发的协议"><a href="#使用KDC进行密钥分发的协议" class="headerlink" title="使用KDC进行密钥分发的协议"></a>使用KDC进行密钥分发的协议</h3><p>Needham-Schroeder 协议，它是 Kerberos 的核心，Kerberos 是一种重要且广泛使用的用于执行身份验证和支持安全通信的服务<br><img src="/2025/04/28/Introduction%20To%20Modern%20Cryptography%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/file-20250425203749171.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="11-3密钥交换和Diffie-Hellman协议"><a href="#11-3密钥交换和Diffie-Hellman协议" class="headerlink" title="11.3密钥交换和Diffie-Hellman协议"></a>11.3密钥交换和Diffie-Hellman协议</h2><p>KDC协议在实践中仍然不能解决密钥分发问题</p>
<p>Diffie-Hellman密钥交换协议允许两个当事人，Alice和Bob，在事先没有交换任何秘密信息的情况下达成一个秘密密钥，该方法基于循环群。</p>
<h3 id="安全的设定和定义"><a href="#安全的设定和定义" class="headerlink" title="安全的设定和定义"></a>安全的设定和定义</h3><h3 id="Diffie-Hellman密钥交换协议"><a href="#Diffie-Hellman密钥交换协议" class="headerlink" title="Diffie-Hellman密钥交换协议"></a>Diffie-Hellman密钥交换协议</h3><p>该协议本身基于群$Z_p^*$，其中$p$是大素数。在Diffie-Hellman（DH）密钥交换中可以使用的素数是标准化的—也就是说素数$p$必须是安全素数，即$p&#x3D;2q+1$，其中$q$也是素数。</p>
<p><strong>注意</strong>：自$p&#x3D;2q+1$以来，素数$q$可以整除$p−1$，因此群$Z_p^∗​$有一个阶为$q$的元素$g$，$g$的幂生成群$⟨g⟩:&#x3D;{0,1,⋯,q−1}$。结果，这个群$⟨g⟩$是群$Z_p^∗​$的子群。</p>
<p><strong>过程：</strong></p>
<ul>
<li><p>Alice随机选择一个均匀的$a←_R​Z_q​$，即$a\in [0,p-1]$并计算$A:&#x3D;g^a$。同样，Bob选择一个均匀的$b←_R​Z_q​$并计算$B:&#x3D;g^b$。</p>
</li>
<li><p>然后，Alice和Bob交换他们各自计算出的值：Alice从Bob那里获得$B$，Bob从Alice那里获得$A$。</p>
</li>
<li><p>现在，Alice计算$B^a&#x3D;(g^b)^a&#x3D;g^{ab}$，Bob计算$A^ b&#x3D;(g^a)^b&#x3D;g^{ab}$，这样双方已经到达了相同的密钥$k:&#x3D;g^{ab}$！</p>
</li>
<li><p>即使攻击者知道了$g^a和g^b$，他也无法算出$g^{ab}$，因为如果想的到这个密钥，他必须求解<strong>离散对数</strong>问题</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>变量</th>
<th>Alice</th>
<th>Bob</th>
<th>Eve</th>
</tr>
</thead>
<tbody><tr>
<td>$p$</td>
<td>known</td>
<td>known</td>
<td>known</td>
</tr>
<tr>
<td>$q$</td>
<td>known</td>
<td>known</td>
<td>known</td>
</tr>
<tr>
<td>$g$</td>
<td>known</td>
<td>known</td>
<td>known</td>
</tr>
<tr>
<td>$a$</td>
<td>known</td>
<td>unknown</td>
<td>unknown</td>
</tr>
<tr>
<td>$b$</td>
<td>unknown</td>
<td>known</td>
<td>unknown</td>
</tr>
<tr>
<td>$g^a$</td>
<td>known</td>
<td>known</td>
<td>known</td>
</tr>
<tr>
<td>$g^b$</td>
<td>known</td>
<td>known</td>
<td>known</td>
</tr>
<tr>
<td>$g^{ab}$</td>
<td>known</td>
<td>known</td>
<td>unknown</td>
</tr>
</tbody></table>
<h3 id="活跃对手"><a href="#活跃对手" class="headerlink" title="活跃对手"></a>活跃对手</h3><p>活跃对手这里主要指，主动的攻击者，也就是说攻击者不再是简简单单的监听，而会进行中间人攻击，而Diffie-Hellman协议对于此种攻击完全没有安全性。<br>因此实践应用中要结合签名进行身份认证。</p>
<h2 id="11-4公钥革命"><a href="#11-4公钥革命" class="headerlink" title="11.4公钥革命"></a>11.4公钥革命</h2><p><strong>数字签名（MAC对应物）：</strong><br>使用私钥进行签名，使用公钥进行认证</p>
<p><strong>公钥密码如何解决了私钥密码的局限性：</strong></p>
<ul>
<li>允许在公共通道进行密钥分发</li>
<li>减少了存储密钥的成本，不需要再秘密存储大量密钥</li>
<li>更加适合开放环境，便于之前没有联系的两方建立安全通信</li>
</ul>
<h3 id="为什么要研究私钥密码学？"><a href="#为什么要研究私钥密码学？" class="headerlink" title="为什么要研究私钥密码学？"></a>为什么要研究私钥密码学？</h3><p>私钥密码比公钥密码的效率更高，更适合大量消息的交换。</p>
<h1 id="12-公钥加密"><a href="#12-公钥加密" class="headerlink" title="12.公钥加密"></a>12.公钥加密</h1><h2 id="12-1概述"><a href="#12-1概述" class="headerlink" title="12.1概述"></a>12.1概述</h2><h3 id="与私钥加密的对比"><a href="#与私钥加密的对比" class="headerlink" title="与私钥加密的对比"></a>与私钥加密的对比</h3><p><strong>公钥加密优势（与前面类似）：</strong></p>
<ul>
<li>解决了密钥分发问题</li>
<li>便于除了一个接收方和多个发送方之间的信息传输</li>
<li>不需要知道潜在的发送方的数量和身份，具有开放性</li>
</ul>
<h3 id="公共密钥的安全分发"><a href="#公共密钥的安全分发" class="headerlink" title="公共密钥的安全分发"></a>公共密钥的安全分发</h3><p>安全共享的前提是经过认证</p>
<h2 id="12-2-定义"><a href="#12-2-定义" class="headerlink" title="12.2 定义"></a>12.2 定义</h2><h3 id="12-2-1-针对选择明文攻击的安全性"><a href="#12-2-1-针对选择明文攻击的安全性" class="headerlink" title="12.2.1 针对选择明文攻击的安全性"></a>12.2.1 针对选择明文攻击的安全性</h3><p><strong>命题：</strong> 如果一个公钥加密方案在一个窃听者存在的情况下具有不可区分的加密，这个放啊便是CPA安全的。</p>
<p><strong>选择明文攻击：</strong></p>
<ul>
<li>高效的对手Eve被给予公钥$pk$，并可以使用它来加密她选择的$q$条消息$m_1​,…,m_q​$以获得相应的密文$c_1​,…,c_q​$</li>
<li>如果对于任何两个消息$(μ0​,μ1​)$，由$Gen$生成的公钥$pk$和密文$c:&#x3D;Enc(pk​,⋅)$（它是$μ0​$或$μ1​$的加密），Eve猜测$c$属于$μ0​$或$μ1​$的概率最多只是微不足道地大于$\frac 1 2$，则公钥加密方案$(Gen,Enc,Dec)$是CPA安全的。</li>
</ul>
<h4 id="公钥的不安全性"><a href="#公钥的不安全性" class="headerlink" title="公钥的不安全性"></a>公钥的不安全性</h4><p>由于公钥加密的方案特性，每个攻击者都会十分容易获得加密预言机，也就是说任何<strong>确定性的公钥加密</strong>都是不具有CPA安全性的。<br>因此若想保证CPA安全必须使用<strong>非确定性的公钥加密</strong>，如每次加密前都进行随机填充。</p>
<h3 id="12-2-2-多消息加密"><a href="#12-2-2-多消息加密" class="headerlink" title="12.2.2 多消息加密"></a>12.2.2 多消息加密</h3><p><strong>定理12.6：</strong> 如果说一个加密方案$\Pi$是CPA安全的，那么它也具有不可区分的多消息加密特性</p>
<h4 id="加密任意长度消息"><a href="#加密任意长度消息" class="headerlink" title="加密任意长度消息"></a>加密任意长度消息</h4><p><strong>思路：</strong><br>将长消息分解为多个消息，分别加密后再组合起来，如果原始方案是CPA安全的，那么新方案也是CPA安全的。</p>
<h3 id="12-2-3-针对选择密文攻击的安全性"><a href="#12-2-3-针对选择密文攻击的安全性" class="headerlink" title="12.2.3 针对选择密文攻击的安全性"></a>12.2.3 针对选择密文攻击的安全性</h3><p><strong>CCA攻击方案：</strong></p>
<ul>
<li>修改发送者发送的密文$c$变为$c_0$（如修改”收件人”等固定的地方），然后再从接收者的反应行动推测明文$m$的一些内容</li>
<li>修改密文$c$变为$c_0$，其中把发送人改为自己，后续可能收到回信，从而得到明文$m_0$的一些信息。</li>
</ul>
<h2 id="12-3混合加密和KEM-DEM范例"><a href="#12-3混合加密和KEM-DEM范例" class="headerlink" title="12.3混合加密和KEM&#x2F;DEM范例"></a>12.3混合加密和KEM&#x2F;DEM范例</h2><p><strong>主要思想：</strong></p>
<ul>
<li>发送方：使用$pk$加密私钥密钥$k$得到$c$，使用$k$加密明文$m$得到$c_1$，全部发送给接收方</li>
<li>接收方：使用$sk$解密$c$的到密钥$k$，再使用$k$解密$c_1$得到明文$m$</li>
</ul>
<p>封装操作，一次性完成上面操作<br><strong>KEM（Key Encapsulation Mechanism）：</strong><br><strong>KEM负责安全地传输对称密钥</strong>，确保只有接收方能够获取对称密钥。</p>
<ul>
<li>发送方使用接收方的公钥$pk$将对称密钥$k$封装成一个密文$c$。</li>
<li>接收方使用自己的私钥$sk$从密文$c$中解封装出对称密钥$k$。</li>
</ul>
<p><strong>DEM（Data Encapsulation Mechanism）：</strong><br><strong>DEM负责高效地加密和解密数据</strong>，利用对称加密的高效性。</p>
<ul>
<li>发送方使用对称密钥$k$对明文$m$进行加密，得到密文$c1​$。</li>
<li>接收方使用对称密钥$k$对密文$c1​$进行解密，得到明文$m$。</li>
</ul>
<h3 id="12-3-1-CPA安全"><a href="#12-3-1-CPA安全" class="headerlink" title="12.3.1 CPA安全"></a>12.3.1 CPA安全</h3><p>如果KEM是CPA安全的，且私钥加密方案（DEM）符合基本的安全性，那么混合加密方案也是CPA安全的</p>
<h3 id="12-3-2-CCA安全"><a href="#12-3-2-CCA安全" class="headerlink" title="12.3.2 CCA安全"></a>12.3.2 CCA安全</h3><p>如果KEM是CCA安全的，且私钥加密方案（DEM）也是CCA安全的，那么混合加密方案也是CCA安全的</p>
<h2 id="12-4-基于CDH-DDH的加密"><a href="#12-4-基于CDH-DDH的加密" class="headerlink" title="12.4 基于CDH&#x2F;DDH的加密"></a>12.4 基于CDH&#x2F;DDH的加密</h2><h3 id="12-4-1-El-Gamal加密"><a href="#12-4-1-El-Gamal加密" class="headerlink" title="12.4.1 El Gamal加密"></a>12.4.1 El Gamal加密</h3><p><strong>密钥生成：</strong></p>
<ul>
<li>Alice使用生成元$g$得到一个阶为$q$的循环群$G$</li>
<li>随机均匀选择一个$x\in [1,q-1]$计算$h:&#x3D;g^x$</li>
<li>公开公钥$(G,q,g,h)$，保留$x$作为私钥<br><strong>加密算法：</strong></li>
<li>Bob随机均匀选择$y\in [1,q-1]$，计算密文$c_1:&#x3D;g^y$</li>
<li>计算共享秘密$s:&#x3D;h^y$</li>
<li>计算$c_2:&#x3D;ms$</li>
<li>将密文$(c_1,c_2)&#x3D;(g^y,mh^y)&#x3D;(g^y,m(g^x)^y)$<blockquote>
<p>如果一个人知道了m，那么它很容易就能知道$h^y$的值。因此对每一条信息都产生一个新的$y$可以提高安全性。所以$y$也被称作<strong>临时密钥</strong></p>
</blockquote>
</li>
</ul>
<p><strong>解密算法：</strong></p>
<ul>
<li>Alice计算共享秘密$s:&#x3D;c_1^x$</li>
<li>计算$m&#x3D;c_2s^{-1}$</li>
</ul>
<h3 id="实施问题"><a href="#实施问题" class="headerlink" title="实施问题"></a>实施问题</h3><ul>
<li>共享公钥参数</li>
<li>组别选择</li>
<li>消息空间</li>
</ul>
<p><strong>基于El Gamal的KEM构造</strong><br><strong>Gen（密钥生成）</strong>：</p>
<ul>
<li>输入安全参数$1^n$，运行群生成算法$G(1^n)$，得到群$G、阶q和生成元g$。</li>
<li>随机选择一个私钥$x∈Z_q$​，计算公钥$h&#x3D;g^x$。     </li>
<li>定义一个函数$H:G→{0,1}^ℓ$，其中$ℓ$是某个函数的值。</li>
<li>公钥为$(G,q,g,h,H)$，私钥为$(G,q,g,x)$。</li>
</ul>
<p><strong>Encaps（封装）</strong>：   </p>
<ul>
<li>输入公钥$pk&#x3D;(G,q,g,h,H)$。     </li>
<li>随机选择$y∈Zq_​$，计算密文$c&#x3D;g^y$。    </li>
<li>计算对称密钥$K&#x3D;H(h^y)$。</li>
<li>输出密文$c$和对称密钥$K$。</li>
</ul>
<p><strong>Decaps（解封装）</strong>：</p>
<ul>
<li>输入私钥$sk&#x3D;(G,q,g,x)$和密文$c∈G$。</li>
<li>计算$cx&#x3D;(g^y)^x&#x3D;g^{xy}$。</li>
<li>计算对称密钥$K&#x3D;H(g^{xy})$。</li>
<li>输出对称密钥$K$。</li>
</ul>
<blockquote>
<p>ps：其中$H$应为一种理想化的Hash函数</p>
</blockquote>
<blockquote>
<p>CDH是一个<strong>计算问题</strong>，要求计算出具体的共享密钥$g^{ab}$。<br>DDH是一个<strong>决策问题</strong>，要求判断一个给定的群元素是否是两个其他群元素的“组合”</p>
</blockquote>
<h3 id="12-4-2-基于DDH的密钥封装"><a href="#12-4-2-基于DDH的密钥封装" class="headerlink" title="12.4.2 基于DDH的密钥封装"></a>12.4.2 基于DDH的密钥封装</h3><p><strong>定理：</strong> 如果DDH（决策性Diffie-Hellman）问题在群G中是困难的，并且H按照上边方式选择，那么这种构造是一个CPA安全的KEM</p>
<h3 id="12-4-3-基于CDH的随机预言模型中的KEM"><a href="#12-4-3-基于CDH的随机预言模型中的KEM" class="headerlink" title="12.4.3 基于CDH的随机预言模型中的KEM"></a>12.4.3 基于CDH的随机预言模型中的KEM</h3><p><strong>CDH假设</strong>：CDH假设表明，给定$g^x$和$g^y$，计算$g^{xy}$是困难的。<br><strong>定理：</strong> 如果CDH问题是困难的，并且 H 被建模为随机预言，那么Construction 12.19是CPA安全的</p>
<h3 id="12-4-4-选择密文安全性和DHIES-ECIES"><a href="#12-4-4-选择密文安全性和DHIES-ECIES" class="headerlink" title="12.4.4 选择密文安全性和DHIES&#x2F;ECIES"></a>12.4.4 选择密文安全性和DHIES&#x2F;ECIES</h3><p><strong>定理：</strong> 如果假设$gap-CDH$问题是困难的，那么KEM可以实现CCA安全<br><strong>gap-CDH假设：</strong><br>Gap-CDH假设是CDH问题的一个更强版本，它假设即使攻击者可以访问一个解决DDH问题的预言机，CDH问题仍然是困难的。换句话说，即使攻击者可以判断$g^x$和$g^y$是否与$g^{xy}$有关，他们仍然无法计算$g^{xy}$。</p>
<p><strong>DHIES&#x2F;ECIES方案：</strong><br>这是一个CCA安全的加密方案，结合KEM和私钥加密方案（如CPA安全的对称加密方案）以及MAC。<br><strong>Gen：</strong></p>
<ul>
<li>输入安全参数$1^n$，允许群生成算法$G(1^n)$，得到群$G$、阶$q$和生成元$g$</li>
<li>随机选择$x\in Z_q$，计算$h&#x3D;g^x$</li>
<li>定义一个函数$H：G\to {0,1}^{2n}$</li>
<li>公钥${G,q,g,h,H}$，私钥为$x$</li>
</ul>
<p><strong>Enc：</strong></p>
<ul>
<li>输入公钥$pk&#x3D;(G,q,g,h,H)$和消息$m$</li>
<li>随机选择$y\in Z_q$，计算$k_E||k_M&#x3D;H(h^y)$，其中$k_E$是对称加密密钥，$k_M$是MAC密钥</li>
<li>使用对称加密方案$\Pi <em>E$加密消息$m$，得到$c_0&#x3D;Enc</em>{k_E}(m)$</li>
<li>计算MAC值$t&#x3D;Mac_{k_M}(c_0)$</li>
<li>输出密文$(g^y,c_0,t)$</li>
</ul>
<p><strong>Dec：</strong></p>
<ul>
<li>输入私钥$sk&#x3D;(G,q,g,x,H)$和密文$(c,c_0,t)$</li>
<li>检查$c\in G$，如果$c\notin G$，返回$\perp$</li>
<li>计算$k_E||k_E&#x3D;H(c^x)$</li>
<li>验证MAC值$Vefy_{k_E}(c_0,t)$。得到消息$m&#x3D;Dec_{k_E}(c_0)$</li>
</ul>
<p><strong>DHIES&#x2F;ECIES:</strong></p>
<ul>
<li><strong>DHIES</strong>：当群$G$是有限域的循环子群时，这种构造被称为DHIES。</li>
<li><strong>ECIES</strong>：当群$G$是椭圆曲线群时，这种构造被称为ECIES。</li>
</ul>
<h2 id="12-5基于RSA的加密"><a href="#12-5基于RSA的加密" class="headerlink" title="12.5基于RSA的加密"></a>12.5基于RSA的加密</h2><h3 id="12-5-1-普通RSA加密"><a href="#12-5-1-普通RSA加密" class="headerlink" title="12.5.1 普通RSA加密"></a>12.5.1 普通RSA加密</h3><h4 id="普通RSA中的更多攻击"><a href="#普通RSA中的更多攻击" class="headerlink" title="普通RSA中的更多攻击"></a>普通RSA中的更多攻击</h4><ul>
<li>m恢复效率提升两倍<br><strong>明文分解</strong>：假设$m$是一个均匀的$n$位整数，那么对于适当的$α≈\frac 12$​，可以证明以高概率存在整数$r$和$s$，使得$1&lt;r≤s≤2^{αn}$且$m&#x3D;rs$</li>
</ul>
<p><strong>攻击过程</strong>：<br>1.计算$x_r​&#x3D;cr^{−e} \mod N$，这实际上是将密文$c$除以$r^e$。<br>2.如果存在某个$s$使得$s^e\mod N&#x3D;x_r$​，则$m&#x3D;r⋅s$。<br>3.通过排序和二分查找，可以在$O(T)$的时间内找到这样的$r$和$s$</p>
<ul>
<li>小e加密</li>
<li>m部分已知</li>
<li>加密相关消息</li>
<li>向多个接收者发送相同消息</li>
</ul>
<blockquote>
<p>这部分内容可以看我博客CTF RSA题型</p>
</blockquote>
<h3 id="12-5-2-Padded-RSA-和-PKCS-1-v1-5"><a href="#12-5-2-Padded-RSA-和-PKCS-1-v1-5" class="headerlink" title="12.5.2 Padded RSA 和 PKCS#1 v1.5"></a>12.5.2 Padded RSA 和 PKCS#1 v1.5</h3><p><strong>随机填充的作用</strong>：随机填充$r$使得加密过程不再是确定性的，从而提高了安全性</p>
<h4 id="RSA-PKCS-1-v1-5"><a href="#RSA-PKCS-1-v1-5" class="headerlink" title="RSA  PKCS#1 v1.5"></a>RSA  PKCS#1 v1.5</h4><p><strong>消息长度：</strong> 消息$m$的长度为$D$字节，其中$1\leq D\leq k-11$，$k$是$N$的字节长度<br><strong>加密过程：</strong></p>
<ul>
<li>选择一个长为$k-D-3$字节的随机填充$r$，且$r$中没有字节等于0x00</li>
<li>填充后的消息$p&#x3D;0x00||0x02||r||0x00||m$</li>
<li>计算密文$c&#x3D;p^e\mod N$</li>
</ul>
<p><strong>缺陷：</strong><br>填充长度可能太短，攻击者可通过暴力攻击恢复部分明文</p>
<h3 id="12-5-3-无随机预言的CPA安全加密"><a href="#12-5-3-无随机预言的CPA安全加密" class="headerlink" title="12.5.3 无随机预言的CPA安全加密"></a>12.5.3 无随机预言的CPA安全加密</h3><blockquote>
<p>本小节只进行理论上的讨论，因为实际中有更高效的构造方案</p>
</blockquote>
<h4 id="RSA问题的硬核谓词"><a href="#RSA问题的硬核谓词" class="headerlink" title="RSA问题的硬核谓词"></a>RSA问题的硬核谓词</h4><p><strong>定义</strong>：硬核谓词是一种从单向函数的输出中难以计算的特定信息。对于RSA问题，最小有效位（lsb）被证明是一个硬核谓词。</p>
<h4 id="构建KEM"><a href="#构建KEM" class="headerlink" title="构建KEM"></a>构建KEM</h4><p><strong>目标</strong>：扩展单比特加密方案，生成一个长度为$n$的密钥。<br><strong>方法</strong>：通过重复应用RSA置换（即模$N$下的$e$次幂运算），从一个初始随机值$c_1​$开始，依次计算$c_1^e \mod N$，$(c_1^e​)^e\mod N$，直到$c_1^{e^n} \mod N$。最终的密文是$c_{n+1}$​，而密钥则是由这些中间值的最小有效位组成的序列。<br><strong>解密过程</strong>：接收方使用私钥$d_0​&#x3D;[d^n\mod ϕ(N)]$反向计算，恢复初始值$c_1$​，并从中提取密钥。<br><strong>定理12.35</strong>：如果RSA问题是困难的，那么该构建是一个CPA安全的KEM</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p><strong>加密</strong>：需要$2n$次模$N$的乘法。<br><strong>解密</strong>：需要一次完整的模$N$指数运算（大约3072次模$N$的乘法）加上额外的$2n$次模$N$的乘法。</p>
<h3 id="12-5-4-OAEP-and-PKCS-1-v2"><a href="#12-5-4-OAEP-and-PKCS-1-v2" class="headerlink" title="12.5.4 OAEP and PKCS #1 v2"></a>12.5.4 OAEP and PKCS #1 v2</h3><h4 id="普通RSA加密"><a href="#普通RSA加密" class="headerlink" title="普通RSA加密"></a>普通RSA加密</h4><p>纯RSA加密连CPA安全都无法保证，因为它是一个确定性加密方案。</p>
<h4 id="RSA-PKCS-1-v1-5-1"><a href="#RSA-PKCS-1-v1-5-1" class="headerlink" title="RSA PKCS #1 v1.5"></a>RSA PKCS #1 v1.5</h4><p>PKCS #1 v1.5存在一种更实用的CCA攻击，攻击者不需要完整的解密预言机，只需要一个“部分”解密预言机，该预言机指示解密是否成功。这种攻击利用了PKCS #1 v1.5在解密时对填充格式的检查。</p>
<p>Bleichenbacher攻击：攻击者通过选择随机的$s∈Z_N^∗​$并提交$c′&#x3D;[s^e⋅c\mod N]$给解密者，利用解密者的响应来逐步恢复明文$m$。</p>
<h4 id="RSA-OAEP构建"><a href="#RSA-OAEP构建" class="headerlink" title="RSA-OAEP构建"></a>RSA-OAEP构建</h4><p><strong>Gen：</strong></p>
<ul>
<li>输入安全参数$1^n$，允许$Gen(1^n)$，得到公钥$(N,e)$和私钥$(N,d)$</li>
<li>输出公钥$pk&#x3D;(N,e)$和私钥$sk&#x3D;(N,d)$</li>
</ul>
<p><strong>Enc：</strong></p>
<ul>
<li>输入公钥$pk&#x3D;(N,e)$和消息$m\in {0,1}^l$</li>
<li>设置$m_0:&#x3D;m||0^k$（即在$m$后加$k$个0）</li>
<li>随机选择$r\in {0,1}^k$</li>
<li>计算$t:&#x3D;m_0 \oplus G(r)$和$s:&#x3D;r\oplus H(t)$</li>
<li>设置$m_1:&#x3D;s||t$</li>
<li>输出密文$c:&#x3D;[m_1^e \mod N]$</li>
</ul>
<p><strong>Dec：</strong></p>
<ul>
<li>输入私钥$sk&#x3D;(N,d)$和密文$c\in Z_N^*$</li>
<li>计算$m_1:&#x3D;[c^d \mod N]$</li>
<li>解析$m_1$为$s||t$</li>
<li>计算$r:&#x3D;H(t)\oplus s$和$m_0:&#x3D;G(r)\oplus t$</li>
<li>检查$m_0$的最后$k$位是否全为0，如果不是，返回错误</li>
<li>否则丢弃$m_0$的最后$k$个0，输出剩余的$l$位作为消息$m$</li>
</ul>
<h4 id="Manger’s-CPA-on-PKCS-1-v2-0"><a href="#Manger’s-CPA-on-PKCS-1-v2-0" class="headerlink" title="Manger’s CPA on PKCS #1 v2.0."></a>Manger’s CPA on PKCS #1 v2.0.</h4><p><strong>Manger攻击</strong>：2001年，James Manger发现了一种针对PKCS #1 v2.0的CCA攻击，即使PKCS #1 v2.0是RSA-OAEP的一个变体。这种攻击利用了某些实现中返回不同错误信息的问题。</p>
<h3 id="12-5-5-随机预言模型中CCA安全的KEM"><a href="#12-5-5-随机预言模型中CCA安全的KEM" class="headerlink" title="12.5.5 随机预言模型中CCA安全的KEM"></a>12.5.5 随机预言模型中CCA安全的KEM</h3><p><strong>构造</strong></p>
<p><strong>Gen</strong></p>
<ul>
<li>输入安全参数$1^n$。</li>
<li>运行RSA密钥生成算法$GenRSA(1^n)$，得到公钥$(N,e)$和私钥$(N,d)$。</li>
<li>定义一个函数$H:Z_N^∗​→{0,1}^n$，该函数在分析中被建模为随机预言。</li>
</ul>
<p><strong>Encaps</strong></p>
<ul>
<li>输入公钥$pk&#x3D;(N,e)$。</li>
<li>随机选择$r∈Z_N^∗$​。</li>
<li>计算密文$c:&#x3D;[r^e\mod N]$和密钥$k:&#x3D;H(r)$。</li>
<li>输出密文$c$和密钥$k$。</li>
</ul>
<p><strong>Decaps</strong></p>
<ul>
<li>输入私钥$sk&#x3D;(N,d)$和密文$c∈Z_N^∗$​。</li>
<li>计算$r:&#x3D;[c^d\mod N]$。</li>
<li>输出密钥$k:&#x3D;H(r)$。</li>
</ul>
<p><strong>安全性：</strong><br>在CCA攻击中，攻击者可以查询解封装预言机（Decapsulation Oracle），但这些查询不会泄露关于密钥$H(r)$的任何额外信息。<br>解封装预言机的查询只会返回$(H)(\bar r)$，其中$\bar r&#x3D;[\bar c^d\mod N]$。如果$\bar c&#x3D;c$，则$\bar r&#x3D;r$，但$H(r)$仍然是随机的，因为$H$是随机预言。<br>因此，即使攻击者可以查询解封装预言机，也无法区分挑战密文所封装的密钥$k$和一个随机密钥。</p>
<h3 id="12-5-6-RSA的实现问题和陷阱"><a href="#12-5-6-RSA的实现问题和陷阱" class="headerlink" title="12.5.6 RSA的实现问题和陷阱"></a>12.5.6 RSA的实现问题和陷阱</h3><h4 id="使用CRT时的故障攻击"><a href="#使用CRT时的故障攻击" class="headerlink" title="使用CRT时的故障攻击"></a>使用CRT时的故障攻击</h4><p>如果在计算过程中发生错误（例如，攻击者通过硬件篡改诱导错误），可能会导致安全问题。</p>
<h4 id="依赖公钥I"><a href="#依赖公钥I" class="headerlink" title="依赖公钥I"></a>依赖公钥I</h4><ul>
<li><strong>问题</strong>：多个接收者使用相同的模数$N$，但不同的公钥指数$e_i$和私钥指数$d_i$​。</li>
<li><strong>攻击</strong>：给定$N$和$e_i​⋅d_i​&#x3D;1\mod ϕ(N)$，可以高效地分$N$。一旦分解了$N$，就可以计算任何$e_j​$的逆元$d_j$​。</li>
<li><strong>后果</strong>：任何员工都可以读取发送给其他员工的加密消息。</li>
</ul>
<h4 id="依赖公钥II"><a href="#依赖公钥II" class="headerlink" title="依赖公钥II"></a>依赖公钥II</h4><ul>
<li><strong>问题</strong>：即使所有员工相互信任，共享模数$N$仍然不安全。</li>
<li><strong>攻击</strong>：假设相同的明文$m$被加密并发送给两个员工，其公钥分别为$(N,e_1​)$和$(N,e_2​)$，且$gcd(e_1​,e_2​)&#x3D;1$</li>
<li><strong>攻击方法</strong>：攻击者可以看到两个密文$c_1​&#x3D;m^{e_1}​\mod N$和$c_2​&#x3D;m^{e_2}​\mod N$。利用扩展欧几里得算法计算整数$X$和$Y$，使得$Xe_1​+Ye_2​&#x3D;1$。那么$m&#x3D;[c_1^X​⋅c_2^Y​\mod N]$。</li>
<li><strong>后果</strong>：攻击者可以轻松恢复明文$m$</li>
</ul>
<h1 id="13-数据签名方案"><a href="#13-数据签名方案" class="headerlink" title="13.数据签名方案"></a>13.数据签名方案</h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><p>数字签名是一种公钥密码学工具，允许签名者$S$使用其私钥$sk$对消息$m$进行签名，生成签名$σ$。任何知道签名者公钥$pk$的人都可以验证签名的合法性，从而确认消息确实由签名者生成且未被篡改。</p>
<h3 id="与MAC的比较"><a href="#与MAC的比较" class="headerlink" title="与MAC的比较"></a>与MAC的比较</h3><p><strong>MAC局限性：</strong> 无法实现公开验证、不可抵赖性 和签名的可转移性。<br><strong>数字签名优势：</strong></p>
<ul>
<li><strong>公开验证</strong>：任何知道公钥的人都可以验证签名。</li>
<li><strong>不可抵赖性</strong>：签名者无法否认自己对消息的签名。</li>
<li><strong>可转移性</strong>：签名可以被第三方验证，并可进一步传递给其他方。</li>
</ul>
<h3 id="与公钥加密的联系"><a href="#与公钥加密的联系" class="headerlink" title="与公钥加密的联系"></a>与公钥加密的联系</h3><p><strong>误解</strong>：数字签名有时被错误地视为公钥加密的“逆操作”，即通过私钥解密消息来生成签名，通过公钥加密签名来验证。这种观点是错误的，因为：</p>
<ul>
<li><strong>不适用性</strong>：在大多数情况下，这种方法根本不可行。</li>
<li><strong>不安全性</strong>：即使在可以应用的情况下，生成的签名方案也不安全。<br><strong>正确关系</strong>：数字签名和公钥加密是两种不同的密码学原语，尽管它们都基于公钥密码学，但它们的设计和安全性要求不同。</li>
</ul>
<h2 id="13-2定义"><a href="#13-2定义" class="headerlink" title="13.2定义"></a>13.2定义</h2><h3 id="签名方案的安全性"><a href="#签名方案的安全性" class="headerlink" title="签名方案的安全性"></a>签名方案的安全性</h3><p>数字签名方案的安全性要求攻击者无法伪造签名，即使它已经获得了许多其他消息的签名。</p>
<h2 id="13-3-hash签名方案"><a href="#13-3-hash签名方案" class="headerlink" title="13.3 hash签名方案"></a>13.3 hash签名方案</h2><p><strong>构造：</strong><br>假设我们有一个签名方案$Π&#x3D;(Gen,Sign,Vrfy)$，它适用于长度为$ℓ(n)$的消息，以及一个哈希函数 $Π_H​&#x3D;(Gen_H​,H)$，其输出长度为 ℓ(n)。我们构造一个新的签名方案$Π′&#x3D;(Gen′,Sign′,Vrfy′)$，如下所示：</p>
<p><strong>Gen’：</strong></p>
<ul>
<li>输入：安全参数$1^n$。</li>
<li>运行$Gen(1^n)$生成密钥对$(pk,sk)$。</li>
<li>运行$Gen_H​(1^n)$生成哈希函数的参数$s$。</li>
<li>公钥为$⟨pk,s⟩$，私钥为$⟨sk,s⟩$。</li>
</ul>
<p><strong>Sign‘：</strong></p>
<ul>
<li>输入：私钥$⟨sk,s⟩$和消息$m∈{0,1}^∗$。</li>
<li>计算哈希值$H_s​(m)$。</li>
<li>使用私钥$sk$对哈希值$H_s​(m)$进行签名，得到签名$σ←Sign_{sk}​(H_s​(m))$</li>
<li>输出签名$σ$。</li>
</ul>
<p><strong>Vrfy’</strong></p>
<ul>
<li>输入：公钥$⟨pk,s⟩$、消息$m∈{0,1}^∗$和签名$σ$。</li>
<li>计算哈希值$H_s​(m)$。</li>
<li>使用公钥$pk$验证签名$σ$是否是$Hs​(m)$的有效签名，即检查$Vrfy_{pk}​(H_s​(m),σ)&#x3D;1$。</li>
<li>如果验证通过，输出1（有效）；否则输出0（无效）。</li>
</ul>
<p><strong>定理13.4</strong>：如果$Π$是一个安全的签名方案（适用于长度为 ℓ 的消息），并且$Π_H$是抗碰撞性的，那么上面构造就是一个安全的签名方案（适用于任意长度的消息）</p>
<h2 id="13-4-基于RSA的签名"><a href="#13-4-基于RSA的签名" class="headerlink" title="13.4 基于RSA的签名"></a>13.4 基于RSA的签名</h2><h3 id="13-4-1普通RSA签名"><a href="#13-4-1普通RSA签名" class="headerlink" title="13.4.1普通RSA签名"></a>13.4.1普通RSA签名</h3><h4 id="无消息攻击"><a href="#无消息攻击" class="headerlink" title="无消息攻击"></a>无消息攻击</h4><p>攻击者可以选择一个随机的$σ∈Z_N^∗$​，计算$m:&#x3D;[σ^e\mod N]$，然后输出伪造的签名对$(m,σ)$。这种攻击是有效的，因为$σ$是$m$的有效签名。</p>
<h4 id="任意消息上的签名"><a href="#任意消息上的签名" class="headerlink" title="任意消息上的签名"></a>任意消息上的签名</h4><p>攻击者可以选择两个消息$m_1​,m_2​∈Z_N^∗$​，使得$m&#x3D;m_1​⋅m_2 \mod N$。然后获取$m_1​$和$m_2​$的签名$σ1​,σ2$​，并输出$σ:&#x3D;[σ_1​⋅σ_2 \mod N]$作为$m$的签名。这种攻击也是有效的，因为：<br>$σ^e&#x3D;(σ^1​⋅σ_2​)^e&#x3D;(m_1^d​⋅m_2^d​)^e&#x3D;m_1​⋅m_2​&#x3D;m\mod N$</p>
<h3 id="13-4-2-RSA-FDH-和PKCS-1标准"><a href="#13-4-2-RSA-FDH-和PKCS-1标准" class="headerlink" title="13.4.2 RSA-FDH 和PKCS #1标准"></a>13.4.2 RSA-FDH 和PKCS #1标准</h3><p><strong>构造：</strong><br><strong>Gen</strong>：</p>
<ul>
<li>输入安全参数$1^n$。    </li>
<li>运行$GenRSA(1^n)$生成模数$N$和整数$e,d$，满足$ed&#x3D;1modϕ(N)$。 </li>
<li>公钥为$pk&#x3D;(N,e)$，私钥为$sk&#x3D;(N,d)$。</li>
<li>定义一个函数$H:{0,1}∗→Z_N^∗​$</li>
</ul>
<p><strong>Sign</strong>：</p>
<ul>
<li>输入私钥$sk&#x3D;(N,d)$和消息$m∈{0,1}^∗$。    </li>
<li>计算签名$σ:&#x3D;[H(m)^d\mod N]$。</li>
</ul>
<p><strong>Vrfy</strong>：</p>
<ul>
<li>输入公钥$pk&#x3D;(N,e)$、消息$m$和签名$σ$。 </li>
<li>验证是否$σ^e&#x3D;H(m)\mod N$</li>
</ul>
<h4 id="RSA-PKCS-1标准"><a href="#RSA-PKCS-1标准" class="headerlink" title="RSA PKCS #1标准"></a>RSA PKCS #1标准</h4><ul>
<li><strong>PKCS #1 v1.5</strong>：与RSA-FDH非常相似，但存在一些已知的安全性问题。</li>
<li><strong>PKCS #1 v2.1</strong>：包含一个更复杂的方案，可以视为RSA-FDH的随机化变体。</li>
</ul>
<h2 id="13-5离散对数问题的签名"><a href="#13-5离散对数问题的签名" class="headerlink" title="13.5离散对数问题的签名"></a>13.5离散对数问题的签名</h2><h3 id="13-5-1标识方案和签名"><a href="#13-5-1标识方案和签名" class="headerlink" title="13.5.1标识方案和签名"></a>13.5.1标识方案和签名</h3><h4 id="识别方案"><a href="#识别方案" class="headerlink" title="识别方案"></a>识别方案</h4><p>识别方案是一种交互式协议，允许一方（称为“证明者”）向另一方（称为“验证者”）证明其身份。</p>
<h4 id="从识别方案到签名"><a href="#从识别方案到签名" class="headerlink" title="从识别方案到签名"></a>从识别方案到签名</h4><p><strong>Fiat-Shamir变换：</strong></p>
<ul>
<li><strong>变换方法</strong>：Fiat-Shamir变换可以将任何交互式的识别方案转换为非交互式的签名方案。</li>
<li><strong>基本思想</strong>：签名者作为证明者，自己运行识别协议。签名者首先计算初始消息$I$，然后通过哈希函数$H$生成挑战$r$，最后计算响应$s$。签名是$(r,s)$</li>
<li><strong>验证过程</strong>：验证者重新计算 I 并检查$H(I,m)&#x3D;r$。</li>
</ul>
<h3 id="13-5-2-Schnorr-身份识别-签名方案"><a href="#13-5-2-Schnorr-身份识别-签名方案" class="headerlink" title="13.5.2 Schnorr 身份识别&#x2F;签名方案"></a>13.5.2 Schnorr 身份识别&#x2F;签名方案</h3><p><strong>构造</strong>：</p>
<p><strong>Gen</strong>：与识别方案相同。   </p>
<p><strong>Sign</strong>：    </p>
<ul>
<li>选择随机$k∈Z_q​$，计算$I&#x3D;g^k$。</li>
<li>计算$r&#x3D;H(I,m)$</li>
<li>计算$s&#x3D;[rx+k\mod q]$。    </li>
<li>输出签名$(r,s)$。</li>
</ul>
<p><strong>Vrfy</strong>：   </p>
<ul>
<li>计算$I&#x3D;g^s⋅y^{−r}$。</li>
<li>检查是否$H(I,m)&#x3D;r$。</li>
</ul>
<p><strong>安全性</strong>：如果离散对数问题是困难的，并且哈希函数 H 被建模为随机预言，那么Schnorr签名方案是安全的。</p>
<h3 id="13-5-3-DSA和ECDSA"><a href="#13-5-3-DSA和ECDSA" class="headerlink" title="13.5.3 DSA和ECDSA"></a>13.5.3 DSA和ECDSA</h3><h4 id="DSA构造"><a href="#DSA构造" class="headerlink" title="DSA构造"></a>DSA构造</h4><p><strong>Gen</strong>：<br>运行$G(1^n)$生成群$G$、阶$q$和生成元$g$。选择随机$x∈Z_q$​，计算$y&#x3D;g^x$。公钥为$(G,q,g,y)$，私钥为$x$。</p>
<p> <strong>Sign</strong>：   </p>
<ul>
<li>选择随机$k∈Z_q^∗$​，计算$r&#x3D;F(g^k)$。   </li>
<li>计算$s&#x3D;[k^{−1}⋅(H(m)+xr)\mod q]$。</li>
<li>输出签名$(r,s)$。</li>
</ul>
<p><strong>Vrfy</strong>：</p>
<ul>
<li>计算$I&#x3D;g^{H(m)⋅s^{−1}}⋅y^{r⋅s^{−1}}$。</li>
<li>检查是否$r&#x3D;F(I)$</li>
</ul>
<h4 id="ECDSA构造"><a href="#ECDSA构造" class="headerlink" title="ECDSA构造"></a>ECDSA构造</h4><p> <strong>Gen</strong>：与DSA相同，但群$G$是椭圆曲线群。</p>
<p> <strong>Sign</strong>：</p>
<ul>
<li>选择随机$k∈Z_q^∗$​，计算$r&#x3D;F(g^k)$。</li>
<li>计算$s&#x3D;[k^{−1}⋅(H(m)+xr)\mod q]$。    </li>
<li>输出签名$(r,s)$。</li>
</ul>
<p><strong>Vrfy</strong>：   </p>
<ul>
<li>计算$I&#x3D;g^{H(m)⋅s^{−1}}⋅y^{r⋅s^{−1}}$。    </li>
<li>检查是否$r&#x3D;F(I)$。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Study/" class="category-chain-item">Study</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Crypto/" class="print-no-link">#Crypto</a>
      
        <a href="/tags/%E5%AF%86%E7%A0%81/" class="print-no-link">#密码</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Introduction To Modern Cryptography学习随笔</div>
      <div>http://ramoor.github.io/2025/04/28/Introduction To Modern Cryptography学习随笔/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ramoor</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年4月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/29/Crypto%E5%9F%BA%E7%A1%80%E7%AF%87-MT19937/" title="Crypto基础篇-MT19937">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Crypto基础篇-MT19937</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/16/XYCTF%202025%20Writeup/" title="XYCTF 2025 Writeup">
                        <span class="hidden-mobile">XYCTF 2025 Writeup</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"lPTos9qTFk57xeK53vE7I61e-MdYXbMMI","appKey":"DpXRDnV0ErOnqjSiWrfRvGWm","path":"window.location.pathname","placeholder":"`快来评论啊`","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://lptos9qt.api.lncldglobal.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <!-- 小破站存活时长 --> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         次
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Cherry.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start -->
<script>  
MathJax = {  
	tex: {  
		inlineMath: [['$', '$'], ['\(', '\)']]  
	}  
};  
</script>  
<script id="MathJax-script" async  
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">  
</script>
<!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
